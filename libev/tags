!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ABSPRI	ev.c	1338;"	d	file:
ABSPRI	ev.c	1340;"	d	file:
ACLOCAL	Makefile	/^ACLOCAL = ${SHELL} \/home\/cheng\/company\/sdk\/client\/libev\/missing --run aclocal-1.11$/;"	m
ACLOCAL_M4	Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ALL	ev++.h	/^    ALL = EVBREAK_ALL$/;"	e	enum:ev::how_t
AMTAR	Makefile	/^AMTAR = ${SHELL} \/home\/cheng\/company\/sdk\/client\/libev\/missing --run tar$/;"	m
ANFD	ev.c	/^} ANFD;$/;"	t	typeref:struct:__anon5	file:
ANFS	ev.c	/^} ANFS;$/;"	t	typeref:struct:__anon7	file:
ANHE	ev.c	/^  typedef WT ANHE;$/;"	t	file:
ANHE	ev.c	/^  } ANHE;$/;"	t	typeref:struct:__anon8	file:
ANHE_at	ev.c	1601;"	d	file:
ANHE_at	ev.c	1608;"	d	file:
ANHE_at_cache	ev.c	1602;"	d	file:
ANHE_at_cache	ev.c	1609;"	d	file:
ANHE_w	ev.c	1600;"	d	file:
ANHE_w	ev.c	1607;"	d	file:
ANPENDING	ev.c	/^} ANPENDING;$/;"	t	typeref:struct:__anon6	file:
ANSIG	ev.c	/^} ANSIG;$/;"	t	typeref:struct:__anon9	file:
AR	Makefile	/^AR = ar$/;"	m
ASYNC	ev++.h	/^    ASYNC    = EV_ASYNC,$/;"	e	enum:ev::__anon1
AUTO	ev++.h	/^    AUTO      = EVFLAG_AUTO,$/;"	e	enum:ev::__anon2
AUTOCONF	Makefile	/^AUTOCONF = ${SHELL} \/home\/cheng\/company\/sdk\/client\/libev\/missing --run autoconf$/;"	m
AUTOHEADER	Makefile	/^AUTOHEADER = ${SHELL} \/home\/cheng\/company\/sdk\/client\/libev\/missing --run autoheader$/;"	m
AUTOMAKE	Makefile	/^AUTOMAKE = ${SHELL} \/home\/cheng\/company\/sdk\/client\/libev\/missing --run automake-1.11$/;"	m
AUTOMAKE_OPTIONS	Makefile	/^AUTOMAKE_OPTIONS = foreign$/;"	m
AWK	Makefile	/^AWK = gawk$/;"	m
CC	Makefile	/^CC = gcc$/;"	m
CCDEPMODE	Makefile	/^CCDEPMODE = depmode=gcc3$/;"	m
CCLD	Makefile	/^CCLD = $(CC)$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -O3$/;"	m
CHECK	ev++.h	/^    CHECK    = EV_CHECK,$/;"	e	enum:ev::__anon1
CHILD	ev++.h	/^    CHILD    = EV_CHILD,$/;"	e	enum:ev::__anon1
COMPILE	Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
CONFIG_CLEAN_FILES	Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_CLEAN_VPATH_FILES	Makefile	/^CONFIG_CLEAN_VPATH_FILES =$/;"	m
CONFIG_HEADER	Makefile	/^CONFIG_HEADER = config.h$/;"	m
CPP	Makefile	/^CPP = gcc -E$/;"	m
CPPFLAGS	Makefile	/^CPPFLAGS = $/;"	m
CTAGS	Makefile	/^CTAGS = ctags$/;"	m
CYGPATH_W	Makefile	/^CYGPATH_W = echo$/;"	m
DEFAULT_INCLUDES	Makefile	/^DEFAULT_INCLUDES = -I.$/;"	m
DEFS	Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEF_STAT_INTERVAL	ev.c	3998;"	d	file:
DEPDIR	Makefile	/^DEPDIR = .deps$/;"	m
DEVPOLL	ev++.h	/^    DEVPOLL   = EVBACKEND_DEVPOLL,$/;"	e	enum:ev::__anon2
DHEAP	ev.c	2034;"	d	file:
DISTFILES	Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DIST_ARCHIVES	Makefile	/^DIST_ARCHIVES = $(distdir).tar.gz$/;"	m
DIST_COMMON	Makefile	/^DIST_COMMON = README $(am__configure_deps) $(include_HEADERS) \\$/;"	m
DIST_SOURCES	Makefile	/^DIST_SOURCES = $(libev_la_SOURCES)$/;"	m
DSYMUTIL	Makefile	/^DSYMUTIL = $/;"	m
DUMPBIN	Makefile	/^DUMPBIN = $/;"	m
ECB_AMD64	ev.c	576;"	d	file:
ECB_AMD64_X32	ev.c	574;"	d	file:
ECB_C	ev.c	599;"	d	file:
ECB_C	ev.c	602;"	d	file:
ECB_C11	ev.c	607;"	d	file:
ECB_C99	ev.c	606;"	d	file:
ECB_CONCAT	ev.c	789;"	d	file:
ECB_CONCAT_	ev.c	788;"	d	file:
ECB_CPP	ev.c	595;"	d	file:
ECB_CPP11	ev.c	596;"	d	file:
ECB_EXTERN_C	ev.c	610;"	d	file:
ECB_EXTERN_C	ev.c	614;"	d	file:
ECB_EXTERN_C_BEG	ev.c	611;"	d	file:
ECB_EXTERN_C_BEG	ev.c	615;"	d	file:
ECB_EXTERN_C_END	ev.c	612;"	d	file:
ECB_EXTERN_C_END	ev.c	616;"	d	file:
ECB_GCC_VERSION	ev.c	589;"	d	file:
ECB_GCC_VERSION	ev.c	591;"	d	file:
ECB_H	ev.c	534;"	d	file:
ECB_INFINITY	ev.c	1132;"	d	file:
ECB_INFINITY	ev.c	1134;"	d	file:
ECB_MEMORY_FENCE	ev.c	1318;"	d	file:
ECB_MEMORY_FENCE	ev.c	629;"	d	file:
ECB_MEMORY_FENCE	ev.c	635;"	d	file:
ECB_MEMORY_FENCE	ev.c	639;"	d	file:
ECB_MEMORY_FENCE	ev.c	643;"	d	file:
ECB_MEMORY_FENCE	ev.c	646;"	d	file:
ECB_MEMORY_FENCE	ev.c	649;"	d	file:
ECB_MEMORY_FENCE	ev.c	651;"	d	file:
ECB_MEMORY_FENCE	ev.c	653;"	d	file:
ECB_MEMORY_FENCE	ev.c	657;"	d	file:
ECB_MEMORY_FENCE	ev.c	661;"	d	file:
ECB_MEMORY_FENCE	ev.c	663;"	d	file:
ECB_MEMORY_FENCE	ev.c	665;"	d	file:
ECB_MEMORY_FENCE	ev.c	668;"	d	file:
ECB_MEMORY_FENCE	ev.c	670;"	d	file:
ECB_MEMORY_FENCE	ev.c	672;"	d	file:
ECB_MEMORY_FENCE	ev.c	674;"	d	file:
ECB_MEMORY_FENCE	ev.c	682;"	d	file:
ECB_MEMORY_FENCE	ev.c	698;"	d	file:
ECB_MEMORY_FENCE	ev.c	702;"	d	file:
ECB_MEMORY_FENCE	ev.c	707;"	d	file:
ECB_MEMORY_FENCE	ev.c	712;"	d	file:
ECB_MEMORY_FENCE	ev.c	715;"	d	file:
ECB_MEMORY_FENCE	ev.c	719;"	d	file:
ECB_MEMORY_FENCE	ev.c	736;"	d	file:
ECB_MEMORY_FENCE	ev.c	754;"	d	file:
ECB_MEMORY_FENCE_ACQUIRE	ev.c	1319;"	d	file:
ECB_MEMORY_FENCE_ACQUIRE	ev.c	636;"	d	file:
ECB_MEMORY_FENCE_ACQUIRE	ev.c	640;"	d	file:
ECB_MEMORY_FENCE_ACQUIRE	ev.c	654;"	d	file:
ECB_MEMORY_FENCE_ACQUIRE	ev.c	683;"	d	file:
ECB_MEMORY_FENCE_ACQUIRE	ev.c	703;"	d	file:
ECB_MEMORY_FENCE_ACQUIRE	ev.c	708;"	d	file:
ECB_MEMORY_FENCE_ACQUIRE	ev.c	716;"	d	file:
ECB_MEMORY_FENCE_ACQUIRE	ev.c	759;"	d	file:
ECB_MEMORY_FENCE_NEEDS_PTHREADS	ev.c	751;"	d	file:
ECB_MEMORY_FENCE_RELEASE	ev.c	1320;"	d	file:
ECB_MEMORY_FENCE_RELEASE	ev.c	637;"	d	file:
ECB_MEMORY_FENCE_RELEASE	ev.c	641;"	d	file:
ECB_MEMORY_FENCE_RELEASE	ev.c	655;"	d	file:
ECB_MEMORY_FENCE_RELEASE	ev.c	666;"	d	file:
ECB_MEMORY_FENCE_RELEASE	ev.c	684;"	d	file:
ECB_MEMORY_FENCE_RELEASE	ev.c	704;"	d	file:
ECB_MEMORY_FENCE_RELEASE	ev.c	709;"	d	file:
ECB_MEMORY_FENCE_RELEASE	ev.c	717;"	d	file:
ECB_MEMORY_FENCE_RELEASE	ev.c	763;"	d	file:
ECB_NAN	ev.c	1138;"	d	file:
ECB_NAN	ev.c	1140;"	d	file:
ECB_NEEDS_PTHREADS	ev.c	750;"	d	file:
ECB_NO_SMP	ev.c	196;"	d	file:
ECB_NO_SMP	ev.c	625;"	d	file:
ECB_NO_THREADS	ev.c	191;"	d	file:
ECB_NO_THREADS	ev.c	192;"	d	file:
ECB_PTRSIZE	ev.c	554;"	d	file:
ECB_PTRSIZE	ev.c	558;"	d	file:
ECB_PTRSIZE	ev.c	565;"	d	file:
ECB_PTRSIZE	ev.c	567;"	d	file:
ECB_STDC_VERSION	ev.c	600;"	d	file:
ECB_STDC_VERSION	ev.c	603;"	d	file:
ECB_STDFP	ev.c	1123;"	d	file:
ECB_STRINGIFY	ev.c	791;"	d	file:
ECB_STRINGIFY_	ev.c	790;"	d	file:
ECB_VERSION	ev.c	537;"	d	file:
ECHO_C	Makefile	/^ECHO_C = $/;"	m
ECHO_N	Makefile	/^ECHO_N = -n$/;"	m
ECHO_T	Makefile	/^ECHO_T = $/;"	m
EFD_CLOEXEC	ev.c	440;"	d	file:
EFD_CLOEXEC	ev.c	442;"	d	file:
EFD_NONBLOCK	ev.c	436;"	d	file:
EGREP	Makefile	/^EGREP = \/bin\/grep -E$/;"	m
EMBED	ev++.h	/^    EMBED    = EV_EMBED,$/;"	e	enum:ev::__anon1
EMPTY	ev.c	1343;"	d	file:
EMPTY2	ev.c	1344;"	d	file:
EPOLL	ev++.h	/^    EPOLL     = EVBACKEND_EPOLL,$/;"	e	enum:ev::__anon2
ERROR	ev++.h	/^    ERROR    = EV_ERROR$/;"	e	enum:ev::__anon1
ERROR	ev++.h	80;"	d
ETAGS	Makefile	/^ETAGS = etags$/;"	m
EVBACKEND_ALL	ev.h	/^  EVBACKEND_ALL     = 0x0000003FU, \/* all known backends *\/$/;"	e	enum:__anon12
EVBACKEND_DEVPOLL	ev.h	/^  EVBACKEND_DEVPOLL = 0x00000010U, \/* solaris 8 *\/ \/* NYI *\/$/;"	e	enum:__anon12
EVBACKEND_EPOLL	ev.h	/^  EVBACKEND_EPOLL   = 0x00000004U, \/* linux *\/$/;"	e	enum:__anon12
EVBACKEND_KQUEUE	ev.h	/^  EVBACKEND_KQUEUE  = 0x00000008U, \/* bsd *\/$/;"	e	enum:__anon12
EVBACKEND_MASK	ev.h	/^  EVBACKEND_MASK    = 0x0000FFFFU  \/* all future backends *\/$/;"	e	enum:__anon12
EVBACKEND_POLL	ev.h	/^  EVBACKEND_POLL    = 0x00000002U, \/* !win *\/$/;"	e	enum:__anon12
EVBACKEND_PORT	ev.h	/^  EVBACKEND_PORT    = 0x00000020U, \/* solaris 10 *\/$/;"	e	enum:__anon12
EVBACKEND_SELECT	ev.h	/^  EVBACKEND_SELECT  = 0x00000001U, \/* about anywhere *\/$/;"	e	enum:__anon12
EVBREAK_ALL	ev.h	/^  EVBREAK_ALL    = 2  \/* unloop all loops *\/$/;"	e	enum:__anon14
EVBREAK_CANCEL	ev.h	/^  EVBREAK_CANCEL = 0, \/* undo unloop *\/$/;"	e	enum:__anon14
EVBREAK_ONE	ev.h	/^  EVBREAK_ONE    = 1, \/* unloop once *\/$/;"	e	enum:__anon14
EVBREAK_RECURSE	ev.c	1648;"	d	file:
EVBUFFER_DATA	event_compat.h	166;"	d
EVBUFFER_EOF	event_compat.h	118;"	d
EVBUFFER_ERROR	event_compat.h	119;"	d
EVBUFFER_INPUT	event_compat.h	167;"	d
EVBUFFER_LENGTH	event_compat.h	165;"	d
EVBUFFER_OUTPUT	event_compat.h	168;"	d
EVBUFFER_READ	event_compat.h	116;"	d
EVBUFFER_TIMEOUT	event_compat.h	120;"	d
EVBUFFER_WRITE	event_compat.h	117;"	d
EVENT_FD	event.h	108;"	d
EVENT_H_	event.h	41;"	d
EVENT_SIGNAL	event.h	107;"	d
EVENT_STRINGIFY	event.c	78;"	d	file:
EVENT_VERSION	event.c	79;"	d	file:
EVFLAG_AUTO	ev.h	/^  EVFLAG_AUTO      = 0x00000000U, \/* not quite a mask *\/$/;"	e	enum:__anon11
EVFLAG_FORKCHECK	ev.h	/^  EVFLAG_FORKCHECK = 0x02000000U, \/* check for a fork in each iteration *\/$/;"	e	enum:__anon11
EVFLAG_NOENV	ev.h	/^  EVFLAG_NOENV     = 0x01000000U, \/* do NOT consult environment *\/$/;"	e	enum:__anon11
EVFLAG_NOINOTIFY	ev.h	/^  EVFLAG_NOINOTIFY = 0x00100000U, \/* do not attempt to use inotify *\/$/;"	e	enum:__anon11
EVFLAG_NOSIGFD	ev.h	/^  EVFLAG_NOSIGFD   = 0, \/* compatibility to pre-3.9 *\/$/;"	e	enum:__anon11
EVFLAG_NOSIGMASK	ev.h	/^  EVFLAG_NOSIGMASK = 0x00400000U  \/* avoid modifying the signal mask *\/$/;"	e	enum:__anon11
EVFLAG_SIGNALFD	ev.h	/^  EVFLAG_SIGNALFD  = 0x00200000U, \/* attempt to use signalfd *\/$/;"	e	enum:__anon11
EVLIST_ACTIVE	event.h	74;"	d
EVLIST_INIT	event.h	76;"	d
EVLIST_INSERTED	event.h	72;"	d
EVLIST_INTERNAL	event.h	75;"	d
EVLIST_SIGNAL	event.h	73;"	d
EVLIST_TIMEOUT	event.h	71;"	d
EVLOOP_NONBLOCK	ev.h	826;"	d
EVLOOP_NONBLOCK	event.h	50;"	d
EVLOOP_ONCE	event.h	136;"	d
EVLOOP_ONESHOT	ev.h	827;"	d
EVLOOP_ONESHOT	event.h	53;"	d
EVPP_H__	ev++.h	41;"	d
EVRUN_NOWAIT	ev.h	/^  EVRUN_NOWAIT = 1, \/* do not block\/wait *\/$/;"	e	enum:__anon13
EVRUN_ONCE	ev.h	/^  EVRUN_ONCE   = 2  \/* block *once* only *\/$/;"	e	enum:__anon13
EVUNLOOP_ALL	ev.h	830;"	d
EVUNLOOP_CANCEL	ev.h	828;"	d
EVUNLOOP_ONE	ev.h	829;"	d
EV_A	ev.h	173;"	d
EV_A	ev.h	182;"	d
EV_ACQUIRE_CB	ev.c	1640;"	d	file:
EV_ACQUIRE_CB	ev.c	1644;"	d	file:
EV_ANFD_REIFY	ev.c	1556;"	d	file:
EV_API_DECL	ev.h	199;"	d
EV_API_DECL	ev.h	201;"	d
EV_ASYNC	ev.h	/^  EV_ASYNC    =      0x00080000, \/* async intra-loop signal *\/$/;"	e	enum:__anon10
EV_ASYNC_ENABLE	ev.h	133;"	d
EV_ATOMIC_T	ev.h	157;"	d
EV_AVOID_STDIO	ev.c	211;"	d	file:
EV_AX	ev++.h	/^    struct ev_loop* EV_AX;$/;"	m	struct:ev::loop_ref	typeref:struct:ev::loop_ref::ev_loop	access:public
EV_AX	ev++.h	128;"	d
EV_AX	ev++.h	136;"	d
EV_AX	ev++.h	139;"	d
EV_AX	ev++.h	408;"	d
EV_AX_	ev++.h	132;"	d
EV_AX_	ev++.h	137;"	d
EV_AX_	ev++.h	140;"	d
EV_AX_	ev++.h	409;"	d
EV_A_	ev.h	174;"	d
EV_A_	ev.h	183;"	d
EV_BEGIN_WATCHER	ev++.h	580;"	d
EV_BEGIN_WATCHER	ev++.h	811;"	d
EV_CB	ev.h	254;"	d
EV_CB_DECLARE	ev.h	247;"	d
EV_CB_INVOKE	ev.h	250;"	d
EV_CHECK	ev.h	/^  EV_CHECK    =      0x00008000, \/* event loop finished poll *\/$/;"	e	enum:__anon10
EV_CHECK_ENABLE	ev.h	105;"	d
EV_CHILD	ev.h	/^  EV_CHILD    =      0x00000800, \/* child\/pid had status change *\/$/;"	e	enum:__anon10
EV_CHILD_ENABLE	ev.h	126;"	d
EV_CLEANUP	ev.h	/^  EV_CLEANUP  =      0x00040000, \/* event loop resumed in child *\/$/;"	e	enum:__anon10
EV_CLEANUP_ENABLE	ev.h	117;"	d
EV_COMMON	ev.h	243;"	d
EV_COMPAT3	ev.h	61;"	d
EV_CONSTRUCT	ev++.h	566;"	d
EV_CONSTRUCT	ev++.h	572;"	d
EV_CONSTRUCT	ev++.h	810;"	d
EV_CPP	ev.h	44;"	d
EV_CPP	ev.h	51;"	d
EV_CUSTOM	ev.h	/^  EV_CUSTOM   =      0x01000000, \/* for use by user code *\/$/;"	e	enum:__anon10
EV_DECL_PRIORITY	ev.h	274;"	d
EV_DECL_PRIORITY	ev.h	276;"	d
EV_DEFAULT	ev.h	177;"	d
EV_DEFAULT	ev.h	184;"	d
EV_DEFAULT_	ev.h	178;"	d
EV_DEFAULT_	ev.h	185;"	d
EV_DEFAULT_UC	ev.h	175;"	d
EV_DEFAULT_UC	ev.h	186;"	d
EV_DEFAULT_UC_	ev.h	176;"	d
EV_DEFAULT_UC_	ev.h	187;"	d
EV_EMASK_EPERM	ev_epoll.c	68;"	d	file:
EV_EMBED	ev.h	/^  EV_EMBED    =      0x00010000, \/* embedded event loop needs sweep *\/$/;"	e	enum:__anon10
EV_EMBED_ENABLE	ev.h	137;"	d
EV_EMBED_ENABLE	ev.h	188;"	d
EV_ENABLE	ev_kqueue.c	57;"	d	file:
EV_END_WATCHER	ev++.h	611;"	d
EV_END_WATCHER	ev++.h	812;"	d
EV_ERROR	ev.h	/^  EV_ERROR    = (int)0x80000000  \/* sent when an error occurs *\/$/;"	e	enum:__anon10
EV_ERROR	ev_kqueue.c	213;"	d	file:
EV_ET	event.h	105;"	d
EV_FD_TO_WIN32_HANDLE	ev.c	1364;"	d	file:
EV_FEATURES	ev.h	66;"	d
EV_FEATURE_API	ev.h	75;"	d
EV_FEATURE_BACKENDS	ev.h	77;"	d
EV_FEATURE_CODE	ev.h	72;"	d
EV_FEATURE_CONFIG	ev.h	74;"	d
EV_FEATURE_DATA	ev.h	73;"	d
EV_FEATURE_OS	ev.h	78;"	d
EV_FEATURE_WATCHERS	ev.h	76;"	d
EV_FORK	ev.h	/^  EV_FORK     =      0x00020000, \/* event loop resumed in child *\/$/;"	e	enum:__anon10
EV_FORK_ENABLE	ev.h	113;"	d
EV_FREQUENT_CHECK	ev.c	473;"	d	file:
EV_FREQUENT_CHECK	ev.c	475;"	d	file:
EV_HAVE_EV_TIME	ev_win32.c	147;"	d	file:
EV_HEAP_CACHE_AT	ev.c	365;"	d	file:
EV_H_	ev.h	41;"	d
EV_IDLE	ev.h	/^  EV_IDLE     =      0x00002000, \/* event loop is idling *\/$/;"	e	enum:__anon10
EV_IDLE_ENABLE	ev.h	109;"	d
EV_INLINE	ev.h	193;"	d
EV_INLINE	ev.h	195;"	d
EV_INOTIFY_BUFSIZE	ev.c	4007;"	d	file:
EV_INOTIFY_HASHSIZE	ev.c	331;"	d	file:
EV_INVOKE_PENDING	ev.c	1641;"	d	file:
EV_INVOKE_PENDING	ev.c	1645;"	d	file:
EV_IO	ev.h	/^  EV_IO       =         EV_READ, \/* alias for type-detection *\/$/;"	e	enum:__anon10
EV_LSTAT	ev.c	4240;"	d	file:
EV_LSTAT	ev.c	4242;"	d	file:
EV_MAXPRI	ev.h	85;"	d
EV_MINPRI	ev.h	82;"	d
EV_MULTIPLICITY	ev.h	89;"	d
EV_NONE	ev.h	/^  EV_NONE     =            0x00, \/* no events *\/$/;"	e	enum:__anon10
EV_NO_SMP	ev.c	189;"	d	file:
EV_NO_SMP	ev.c	190;"	d	file:
EV_NO_SMP	ev.c	195;"	d	file:
EV_NSIG	ev.c	228;"	d	file:
EV_NSIG	ev.c	230;"	d	file:
EV_NSIG	ev.c	232;"	d	file:
EV_NSIG	ev.c	234;"	d	file:
EV_NSIG	ev.c	236;"	d	file:
EV_NSIG	ev.c	238;"	d	file:
EV_NSIG	ev.c	240;"	d	file:
EV_NSIG	ev.c	242;"	d	file:
EV_NSIG	ev.c	244;"	d	file:
EV_NSIG	ev.c	246;"	d	file:
EV_P	ev.c	/^  EV_P;$/;"	m	struct:__anon9	file:	access:public
EV_P	ev.h	171;"	d
EV_P	ev.h	180;"	d
EV_PERIODIC	ev.h	/^  EV_PERIODIC =      0x00000200, \/* periodic timer timed out *\/$/;"	e	enum:__anon10
EV_PERIODIC_ENABLE	ev.h	93;"	d
EV_PERSIST	event.h	104;"	d
EV_PID_HASHSIZE	ev.c	327;"	d	file:
EV_PREPARE	ev.h	/^  EV_PREPARE  =      0x00004000, \/* event loop about to poll *\/$/;"	e	enum:__anon10
EV_PREPARE_ENABLE	ev.h	101;"	d
EV_PROTOTYPES	ev.h	206;"	d
EV_PX	ev++.h	/^      EV_PX;$/;"	m	struct:ev::base	access:public
EV_PX	ev++.h	411;"	d
EV_PX	ev++.h	414;"	d
EV_PX	ev++.h	417;"	d
EV_PX	ev++.h	808;"	d
EV_PX_	ev++.h	412;"	d
EV_PX_	ev++.h	415;"	d
EV_PX_	ev++.h	418;"	d
EV_PX_	ev++.h	809;"	d
EV_P_	ev.h	172;"	d
EV_P_	ev.h	181;"	d
EV_READ	ev.h	/^  EV_READ     =            0x01, \/* ev_io detected read will not block *\/$/;"	e	enum:__anon10
EV_READ	event.h	102;"	d
EV_RELEASE_CB	ev.c	1639;"	d	file:
EV_RELEASE_CB	ev.c	1643;"	d	file:
EV_SELECT_IS_WINSOCKET	ev.c	209;"	d	file:
EV_SELECT_USE_FD_SET	ev_select.c	51;"	d	file:
EV_SELECT_USE_FD_SET	ev_select.c	53;"	d	file:
EV_SELECT_USE_FD_SET	ev_select.c	58;"	d	file:
EV_SELECT_USE_FD_SET	ev_select.c	59;"	d	file:
EV_SIGNAL	ev.h	/^  EV_SIGNAL   =      0x00000400, \/* signal was received *\/$/;"	e	enum:__anon10
EV_SIGNAL_ENABLE	ev.h	121;"	d
EV_SIGNAL_ENABLE	ev.h	147;"	d
EV_SIGNAL_ENABLE	ev.h	148;"	d
EV_STAT	ev.h	/^  EV_STAT     =      0x00001000, \/* stat data changed *\/$/;"	e	enum:__anon10
EV_STAT_ENABLE	ev.h	97;"	d
EV_THROW	ev.h	/^  ev_tstamp (*reschedule_cb)(struct ev_periodic *w, ev_tstamp now) EV_THROW; \/* rw *\/$/;"	m	struct:ev_periodic	access:public
EV_THROW	ev.h	46;"	d
EV_THROW	ev.h	48;"	d
EV_THROW	ev.h	52;"	d
EV_TIMEOUT	ev.h	/^  EV_TIMEOUT  =        EV_TIMER, \/* pre 4.0 API compatibility *\/$/;"	e	enum:__anon10
EV_TIMEOUT	event.h	56;"	d
EV_TIMER	ev.h	/^  EV_TIMER    =      0x00000100, \/* timer timed out *\/$/;"	e	enum:__anon10
EV_TS_SET	ev.c	489;"	d	file:
EV_TV_SET	ev.c	488;"	d	file:
EV_UNDEF	ev.h	/^  EV_UNDEF    = (int)0xFFFFFFFF, \/* guaranteed to be invalid *\/$/;"	e	enum:__anon10
EV_USE_4HEAP	ev.c	361;"	d	file:
EV_USE_CLOCK_SYSCALL	ev.c	255;"	d	file:
EV_USE_CLOCK_SYSCALL	ev.c	257;"	d	file:
EV_USE_CLOCK_SYSCALL	ev.c	373;"	d	file:
EV_USE_CLOCK_SYSCALL	ev.c	374;"	d	file:
EV_USE_CLOCK_SYSCALL	ev.c	393;"	d	file:
EV_USE_CLOCK_SYSCALL	ev.c	394;"	d	file:
EV_USE_CLOCK_SYSCALL	ev.c	56;"	d	file:
EV_USE_CLOCK_SYSCALL	ev.c	65;"	d	file:
EV_USE_EPOLL	ev.c	113;"	d	file:
EV_USE_EPOLL	ev.c	116;"	d	file:
EV_USE_EPOLL	ev.c	117;"	d	file:
EV_USE_EPOLL	ev.c	304;"	d	file:
EV_USE_EPOLL	ev.c	306;"	d	file:
EV_USE_EVENTFD	ev.c	158;"	d	file:
EV_USE_EVENTFD	ev.c	161;"	d	file:
EV_USE_EVENTFD	ev.c	162;"	d	file:
EV_USE_EVENTFD	ev.c	336;"	d	file:
EV_USE_EVENTFD	ev.c	338;"	d	file:
EV_USE_FLOOR	ev.c	250;"	d	file:
EV_USE_FLOOR	ev.c	50;"	d	file:
EV_USE_INOTIFY	ev.c	140;"	d	file:
EV_USE_INOTIFY	ev.c	143;"	d	file:
EV_USE_INOTIFY	ev.c	144;"	d	file:
EV_USE_INOTIFY	ev.c	320;"	d	file:
EV_USE_INOTIFY	ev.c	322;"	d	file:
EV_USE_INOTIFY	ev.c	411;"	d	file:
EV_USE_INOTIFY	ev.c	412;"	d	file:
EV_USE_INOTIFY	ev.c	427;"	d	file:
EV_USE_INOTIFY	ev.c	428;"	d	file:
EV_USE_KQUEUE	ev.c	122;"	d	file:
EV_USE_KQUEUE	ev.c	125;"	d	file:
EV_USE_KQUEUE	ev.c	126;"	d	file:
EV_USE_KQUEUE	ev.c	311;"	d	file:
EV_USE_MONOTONIC	ev.c	263;"	d	file:
EV_USE_MONOTONIC	ev.c	272;"	d	file:
EV_USE_MONOTONIC	ev.c	274;"	d	file:
EV_USE_MONOTONIC	ev.c	390;"	d	file:
EV_USE_MONOTONIC	ev.c	391;"	d	file:
EV_USE_MONOTONIC	ev.c	401;"	d	file:
EV_USE_MONOTONIC	ev.c	402;"	d	file:
EV_USE_MONOTONIC	ev.c	61;"	d	file:
EV_USE_MONOTONIC	ev.c	70;"	d	file:
EV_USE_MONOTONIC	ev.c	77;"	d	file:
EV_USE_NANOSLEEP	ev.c	284;"	d	file:
EV_USE_NANOSLEEP	ev.c	286;"	d	file:
EV_USE_NANOSLEEP	ev.c	86;"	d	file:
EV_USE_NANOSLEEP	ev.c	89;"	d	file:
EV_USE_NANOSLEEP	ev.c	90;"	d	file:
EV_USE_POLL	ev.c	104;"	d	file:
EV_USE_POLL	ev.c	107;"	d	file:
EV_USE_POLL	ev.c	108;"	d	file:
EV_USE_POLL	ev.c	296;"	d	file:
EV_USE_POLL	ev.c	298;"	d	file:
EV_USE_POLL	ev.c	380;"	d	file:
EV_USE_POLL	ev.c	381;"	d	file:
EV_USE_PORT	ev.c	131;"	d	file:
EV_USE_PORT	ev.c	134;"	d	file:
EV_USE_PORT	ev.c	135;"	d	file:
EV_USE_PORT	ev.c	315;"	d	file:
EV_USE_REALTIME	ev.c	266;"	d	file:
EV_USE_REALTIME	ev.c	279;"	d	file:
EV_USE_REALTIME	ev.c	406;"	d	file:
EV_USE_REALTIME	ev.c	407;"	d	file:
EV_USE_REALTIME	ev.c	58;"	d	file:
EV_USE_REALTIME	ev.c	73;"	d	file:
EV_USE_REALTIME	ev.c	80;"	d	file:
EV_USE_SELECT	ev.c	291;"	d	file:
EV_USE_SELECT	ev.c	370;"	d	file:
EV_USE_SELECT	ev.c	371;"	d	file:
EV_USE_SELECT	ev.c	95;"	d	file:
EV_USE_SELECT	ev.c	98;"	d	file:
EV_USE_SELECT	ev.c	99;"	d	file:
EV_USE_SIGNALFD	ev.c	149;"	d	file:
EV_USE_SIGNALFD	ev.c	152;"	d	file:
EV_USE_SIGNALFD	ev.c	153;"	d	file:
EV_USE_SIGNALFD	ev.c	344;"	d	file:
EV_USE_SIGNALFD	ev.c	346;"	d	file:
EV_USE_STDEXCEPT	ev++.h	50;"	d
EV_VERIFY	ev.c	357;"	d	file:
EV_VERSION_MAJOR	ev.h	211;"	d
EV_VERSION_MINOR	ev.h	212;"	d
EV_WALK_ENABLE	ev.h	141;"	d
EV_WATCHER	ev.h	280;"	d
EV_WATCHER_LIST	ev.h	287;"	d
EV_WATCHER_TIME	ev.h	291;"	d
EV_WIN32_CLOSE_FD	ev.c	1370;"	d	file:
EV_WIN32_HANDLE_TO_FD	ev.c	1367;"	d	file:
EV_WRAP_H	ev_wrap.h	102;"	d
EV_WRAP_H	ev_wrap.h	3;"	d
EV_WRITE	ev.h	/^  EV_WRITE    =            0x02, \/* ev_io detected write will not block *\/$/;"	e	enum:__anon10
EV_WRITE	event.h	103;"	d
EV__IOFDSET	ev.h	/^  EV__IOFDSET =            0x80, \/* internal use only *\/$/;"	e	enum:__anon10
EXEEXT	Makefile	/^EXEEXT = $/;"	m
EXTRA_DIST	Makefile	/^EXTRA_DIST = LICENSE Changes libev.m4 autogen.sh \\$/;"	m
FGREP	Makefile	/^FGREP = \/bin\/grep -F$/;"	m
FORK	ev++.h	/^    FORK     = EV_FORK,$/;"	e	enum:ev::__anon1
FORKCHECK	ev++.h	/^    FORKCHECK = EVFLAG_FORKCHECK,$/;"	e	enum:ev::__anon2
GREP	Makefile	/^GREP = \/bin\/grep$/;"	m
GZIP_ENV	Makefile	/^GZIP_ENV = --best$/;"	m
HAVE_CLOCK_SYSCALL	config.h	8;"	d
HAVE_DLFCN_H	config.h	11;"	d
HAVE_EPOLL_CTL	config.h	14;"	d
HAVE_EVENTFD	config.h	17;"	d
HAVE_FLOOR	config.h	20;"	d
HAVE_INOTIFY_INIT	config.h	23;"	d
HAVE_INTTYPES_H	config.h	26;"	d
HAVE_MEMORY_H	config.h	35;"	d
HAVE_NANOSLEEP	config.h	38;"	d
HAVE_POLL	config.h	41;"	d
HAVE_POLL_H	config.h	44;"	d
HAVE_SELECT	config.h	53;"	d
HAVE_SIGNALFD	config.h	56;"	d
HAVE_STDINT_H	config.h	59;"	d
HAVE_STDLIB_H	config.h	62;"	d
HAVE_STRINGS_H	config.h	65;"	d
HAVE_STRING_H	config.h	68;"	d
HAVE_SYS_EPOLL_H	config.h	71;"	d
HAVE_SYS_EVENTFD_H	config.h	74;"	d
HAVE_SYS_INOTIFY_H	config.h	80;"	d
HAVE_SYS_SELECT_H	config.h	83;"	d
HAVE_SYS_SIGNALFD_H	config.h	86;"	d
HAVE_SYS_STAT_H	config.h	89;"	d
HAVE_SYS_TYPES_H	config.h	92;"	d
HAVE_UNISTD_H	config.h	95;"	d
HEADERS	Makefile	/^HEADERS = $(include_HEADERS)$/;"	m
HEAP0	ev.c	2035;"	d	file:
HEAP0	ev.c	2085;"	d	file:
HPARENT	ev.c	2036;"	d	file:
HPARENT	ev.c	2086;"	d	file:
IDLE	ev++.h	/^    IDLE     = EV_IDLE,$/;"	e	enum:ev::__anon1
INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_HEADER	Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_SCRIPT	Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_STRIP_PROGRAM	Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
KQUEUE	ev++.h	/^    KQUEUE    = EVBACKEND_KQUEUE,$/;"	e	enum:ev::__anon2
LD	Makefile	/^LD = \/usr\/bin\/ld -m elf_x86_64$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = $/;"	m
LIBOBJS	Makefile	/^LIBOBJS = $/;"	m
LIBS	Makefile	/^LIBS = -lm $/;"	m
LIBTOOL	Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LINK	Makefile	/^LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LIPO	Makefile	/^LIPO = $/;"	m
LN_S	Makefile	/^LN_S = ln -s$/;"	m
LTCOMPILE	Makefile	/^LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LTLIBOBJS	Makefile	/^LTLIBOBJS = $/;"	m
LTLIBRARIES	Makefile	/^LTLIBRARIES = $(lib_LTLIBRARIES)$/;"	m
LT_OBJDIR	config.h	99;"	d
MAINT	Makefile	/^MAINT = #$/;"	m
MAKEINFO	Makefile	/^MAKEINFO = ${SHELL} \/home\/cheng\/company\/sdk\/client\/libev\/missing --run makeinfo$/;"	m
MALLOC_ROUND	ev.c	1720;"	d	file:
MANS	Makefile	/^MANS = $(man_MANS)$/;"	m
MAX_BLOCKTIME	ev.c	486;"	d	file:
MIN_INTERVAL	ev.c	482;"	d	file:
MIN_STAT_INTERVAL	ev.c	4000;"	d	file:
MIN_TIMEJUMP	ev.c	485;"	d	file:
MKDIR_P	Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
NFDBITS	ev_select.c	60;"	d	file:
NFDBITS	ev_select.c	61;"	d	file:
NFDBYTES	ev_select.c	65;"	d	file:
NFS_STAT_INTERVAL	ev.c	3999;"	d	file:
NM	Makefile	/^NM = \/usr\/bin\/nm -B$/;"	m
NMEDIT	Makefile	/^NMEDIT = $/;"	m
NOENV	ev++.h	/^    NOENV     = EVFLAG_NOENV,$/;"	e	enum:ev::__anon2
NONBLOCK	ev++.h	/^    NONBLOCK = EVLOOP_NONBLOCK,$/;"	e	enum:ev::__anon3
NONE	ev++.h	/^    NONE     = EV_NONE,$/;"	e	enum:ev::__anon1
NORMAL_INSTALL	Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_UNINSTALL	Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NOTE_EOF	ev_kqueue.c	60;"	d	file:
NOWAIT	ev++.h	/^    NOWAIT   = EVRUN_NOWAIT,$/;"	e	enum:ev::__anon3
NROFF	Makefile	/^NROFF = nroff$/;"	m
NUMPRI	ev.c	1335;"	d	file:
OBJDUMP	Makefile	/^OBJDUMP = objdump$/;"	m
OBJEXT	Makefile	/^OBJEXT = o$/;"	m
ONCE	ev++.h	/^    ONCE     = EVRUN_ONCE$/;"	e	enum:ev::__anon3
ONE	ev++.h	/^    ONE = EVBREAK_ONE,$/;"	e	enum:ev::how_t
ONESHOT	ev++.h	/^    ONESHOT  = EVLOOP_ONESHOT,$/;"	e	enum:ev::__anon3
OTOOL	Makefile	/^OTOOL = $/;"	m
OTOOL64	Makefile	/^OTOOL64 = $/;"	m
PACKAGE	Makefile	/^PACKAGE = libev$/;"	m
PACKAGE	config.h	102;"	d
PACKAGE_BUGREPORT	Makefile	/^PACKAGE_BUGREPORT = $/;"	m
PACKAGE_BUGREPORT	config.h	105;"	d
PACKAGE_NAME	Makefile	/^PACKAGE_NAME = $/;"	m
PACKAGE_NAME	config.h	108;"	d
PACKAGE_STRING	Makefile	/^PACKAGE_STRING = $/;"	m
PACKAGE_STRING	config.h	111;"	d
PACKAGE_TARNAME	Makefile	/^PACKAGE_TARNAME = $/;"	m
PACKAGE_TARNAME	config.h	114;"	d
PACKAGE_VERSION	Makefile	/^PACKAGE_VERSION = $/;"	m
PACKAGE_VERSION	config.h	117;"	d
PATH_SEPARATOR	Makefile	/^PATH_SEPARATOR = :$/;"	m
PERIODIC	ev++.h	/^    PERIODIC = EV_PERIODIC,$/;"	e	enum:ev::__anon1
POLL	ev++.h	/^    POLL      = EVBACKEND_POLL,$/;"	e	enum:ev::__anon2
PORT	ev++.h	/^    PORT      = EVBACKEND_PORT$/;"	e	enum:ev::__anon2
POST_INSTALL	Makefile	/^POST_INSTALL = :$/;"	m
POST_UNINSTALL	Makefile	/^POST_UNINSTALL = :$/;"	m
PREPARE	ev++.h	/^    PREPARE  = EV_PREPARE,$/;"	e	enum:ev::__anon1
PRE_INSTALL	Makefile	/^PRE_INSTALL = :$/;"	m
PRE_UNINSTALL	Makefile	/^PRE_UNINSTALL = :$/;"	m
RANLIB	Makefile	/^RANLIB = ranlib$/;"	m
RB_ENTRY	event_compat.h	57;"	d
RB_ENTRY	event_compat.h	87;"	d
READ	ev++.h	/^    READ     = EV_READ,$/;"	e	enum:ev::__anon1
SA_RESTART	ev.c	3829;"	d	file:
SED	Makefile	/^SED = \/bin\/sed$/;"	m
SELECT	ev++.h	/^    SELECT    = EVBACKEND_SELECT,$/;"	e	enum:ev::__anon2
SET_MAKE	Makefile	/^SET_MAKE = $/;"	m
SFD_CLOEXEC	ev.c	456;"	d	file:
SFD_CLOEXEC	ev.c	458;"	d	file:
SFD_NONBLOCK	ev.c	452;"	d	file:
SHELL	Makefile	/^SHELL = \/bin\/sh$/;"	m
SIGFPE_REQ	ev_win32.c	/^volatile double SIGFPE_REQ = 0.0f;$/;"	v
SIGNAL	ev++.h	/^    SIGNAL   = EV_SIGNAL,$/;"	e	enum:ev::__anon1
SOURCES	Makefile	/^SOURCES = $(libev_la_SOURCES)$/;"	m
STAT	ev++.h	/^    STAT     = EV_STAT,$/;"	e	enum:ev::__anon1
STDC_HEADERS	config.h	120;"	d
STRIP	Makefile	/^STRIP = strip$/;"	m
T	ev.c	/^  template<typename T, int N>$/;"	v
TAILQ_ENTRY	event_compat.h	49;"	d
TAILQ_ENTRY	event_compat.h	78;"	d
TIMEOUT	ev++.h	/^    TIMEOUT  = EV_TIMEOUT,$/;"	e	enum:ev::__anon1
TIMER	ev++.h	/^    TIMER    = EV_TIMER,$/;"	e	enum:ev::__anon1
UNDEF	ev++.h	/^    UNDEF    = EV_UNDEF,$/;"	e	enum:ev::__anon1
UPHEAP_DONE	ev.c	2037;"	d	file:
UPHEAP_DONE	ev.c	2087;"	d	file:
VAR	ev.c	1618;"	d	file:
VAR	ev.c	1620;"	d	file:
VAR	ev.c	1630;"	d	file:
VAR	ev.c	1632;"	d	file:
VARx	ev_vars.h	203;"	d
VARx	ev_vars.h	40;"	d
VERSION	Makefile	/^VERSION = 4.19$/;"	m
VERSION	config.h	123;"	d
VERSION_INFO	Makefile	/^VERSION_INFO = 4:0:0$/;"	m
W	ev.c	/^typedef ev_watcher *W;$/;"	t	file:
WCONTINUED	ev.c	2448;"	d	file:
WIFCONTINUED	ev.c	2424;"	d	file:
WIN32_LEAN_AND_MEAN	ev.c	205;"	d	file:
WIN32_LEAN_AND_MEAN	event_compat.h	33;"	d
WIN32_LEAN_AND_MEAN	event_compat.h	35;"	d
WL	ev.c	/^typedef ev_watcher_list *WL;$/;"	t	file:
WRITE	ev++.h	/^    WRITE    = EV_WRITE,$/;"	e	enum:ev::__anon1
WT	ev.c	/^typedef ev_watcher_time *WT;$/;"	t	file:
_DARWIN_UNLIMITED_SELECT	ev.c	220;"	d	file:
_EVENT_DEFINED_RBENTRY	event_compat.h	56;"	d
_EVENT_DEFINED_RBENTRY	event_compat.h	88;"	d
_EVENT_DEFINED_TQENTRY	event_compat.h	48;"	d
_EVENT_DEFINED_TQENTRY	event_compat.h	81;"	d
_EVENT_LOG_DEBUG	event.h	141;"	d
_EVENT_LOG_ERR	event.h	144;"	d
_EVENT_LOG_MSG	event.h	142;"	d
_EVENT_LOG_WARN	event.h	143;"	d
__anon5::egen	ev.c	/^  unsigned int egen;    \/* generation counter to counter epoll bugs *\/$/;"	m	struct:__anon5	file:	access:public
__anon5::emask	ev.c	/^  unsigned char emask;  \/* the epoll backend stores the actual kernel mask in here *\/$/;"	m	struct:__anon5	file:	access:public
__anon5::events	ev.c	/^  unsigned char events; \/* the events watched for *\/$/;"	m	struct:__anon5	file:	access:public
__anon5::handle	ev.c	/^  SOCKET handle;$/;"	m	struct:__anon5	file:	access:public
__anon5::head	ev.c	/^  WL head;$/;"	m	struct:__anon5	file:	access:public
__anon5::or	ev.c	/^  OVERLAPPED or, ow;$/;"	m	struct:__anon5	file:	access:public
__anon5::ow	ev.c	/^  OVERLAPPED or, ow;$/;"	m	struct:__anon5	file:	access:public
__anon5::reify	ev.c	/^  unsigned char reify;  \/* flag set when this ANFD needs reification (EV_ANFD_REIFY, EV__IOFDSET) *\/$/;"	m	struct:__anon5	file:	access:public
__anon5::unused	ev.c	/^  unsigned char unused;$/;"	m	struct:__anon5	file:	access:public
__anon6::events	ev.c	/^  int events; \/* the pending event set for the given watcher *\/$/;"	m	struct:__anon6	file:	access:public
__anon6::w	ev.c	/^  W w;$/;"	m	struct:__anon6	file:	access:public
__anon7::head	ev.c	/^  WL head;$/;"	m	struct:__anon7	file:	access:public
__anon8::at	ev.c	/^    ev_tstamp at;$/;"	m	struct:__anon8	file:	access:public
__anon8::w	ev.c	/^    WT w;$/;"	m	struct:__anon8	file:	access:public
__anon9::EV_P	ev.c	/^  EV_P;$/;"	m	struct:__anon9	file:	access:public
__anon9::head	ev.c	/^  WL head;$/;"	m	struct:__anon9	file:	access:public
__anon9::pending	ev.c	/^  EV_ATOMIC_T pending;$/;"	m	struct:__anon9	file:	access:public
abs_builddir	Makefile	/^abs_builddir = \/home\/cheng\/company\/sdk\/client\/libev$/;"	m
abs_srcdir	Makefile	/^abs_srcdir = \/home\/cheng\/company\/sdk\/client\/libev$/;"	m
abs_top_builddir	Makefile	/^abs_top_builddir = \/home\/cheng\/company\/sdk\/client\/libev$/;"	m
abs_top_srcdir	Makefile	/^abs_top_srcdir = \/home\/cheng\/company\/sdk\/client\/libev$/;"	m
ac_ct_CC	Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_DUMPBIN	Makefile	/^ac_ct_DUMPBIN = $/;"	m
acquire_cb	ev_wrap.h	103;"	d
acquire_cb	ev_wrap.h	4;"	d
activecnt	ev_wrap.h	104;"	d
activecnt	ev_wrap.h	5;"	d
add	event_compat.h	/^	int (*add)(void *, struct event *);$/;"	m	struct:eventop	access:public
adjustheap	ev.c	/^adjustheap (ANHE *heap, int N, int k)$/;"	f	signature:(ANHE *heap, int N, int k)
again	ev++.h	/^    void again () throw ()$/;"	f	namespace:ev	signature:()
am__CONFIG_DISTCLEAN_FILES	Makefile	/^am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\$/;"	m
am__aclocal_m4_deps	Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/libev.m4 \\$/;"	m
am__base_list	Makefile	/^am__base_list = \\$/;"	m
am__cd	Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__configure_deps	Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__depfiles_maybe	Makefile	/^am__depfiles_maybe = depfiles$/;"	m
am__include	Makefile	/^am__include = include$/;"	m
am__install_max	Makefile	/^am__install_max = 40$/;"	m
am__installdirs	Makefile	/^am__installdirs = "$(DESTDIR)$(libdir)" "$(DESTDIR)$(man3dir)" \\$/;"	m
am__leading_dot	Makefile	/^am__leading_dot = .$/;"	m
am__mv	Makefile	/^am__mv = mv -f$/;"	m
am__nobase_list	Makefile	/^am__nobase_list = $(am__nobase_strip_setup); \\$/;"	m
am__nobase_strip	Makefile	/^am__nobase_strip = \\$/;"	m
am__nobase_strip_setup	Makefile	/^am__nobase_strip_setup = \\$/;"	m
am__quote	Makefile	/^am__quote = $/;"	m
am__remove_distdir	Makefile	/^am__remove_distdir = \\$/;"	m
am__strip_dir	Makefile	/^am__strip_dir = f=`echo $$p | sed -e 's|^.*\/||'`;$/;"	m
am__tar	Makefile	/^am__tar = ${AMTAR} chof - "$$tardir"$/;"	m
am__untar	Makefile	/^am__untar = ${AMTAR} xf -$/;"	m
am__vpath_adj	Makefile	/^am__vpath_adj = case $$p in \\$/;"	m
am__vpath_adj_setup	Makefile	/^am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;$/;"	m
am_libev_la_OBJECTS	Makefile	/^am_libev_la_OBJECTS = ev.lo event.lo$/;"	m
anfdmax	ev_wrap.h	105;"	d
anfdmax	ev_wrap.h	6;"	d
anfds	ev_wrap.h	106;"	d
anfds	ev_wrap.h	7;"	d
arg	ev.c	/^  void *arg;$/;"	m	struct:ev_once	file:	access:public
arg	event.c	/^  void *arg;$/;"	m	struct:ev_x_once	file:	access:public
array_free	ev.c	1774;"	d	file:
array_init_zero	ev.c	1752;"	d	file:
array_needsize	ev.c	1755;"	d	file:
array_nextsize	ev.c	/^array_nextsize (int elem, int cur, int cnt)$/;"	f	signature:(int elem, int cur, int cnt)
array_realloc	ev.c	/^array_realloc (int elem, void *base, int *cur, int cnt)$/;"	f	file:	signature:(int elem, void *base, int *cur, int cnt)
array_verify	ev.c	/^array_verify (EV_P_ W *ws, int cnt)$/;"	f	file:	signature:(EV_P_ W *ws, int cnt)
as_func_failure	configure	/^as_func_failure () {$/;"	f
as_func_ret_failure	configure	/^as_func_ret_failure () {$/;"	f
as_func_ret_success	configure	/^as_func_ret_success () {$/;"	f
as_func_success	configure	/^as_func_success () {$/;"	f
async	ev.h	/^  struct ev_async async;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_async	access:public
async_pending	ev++.h	/^    bool async_pending () throw ()$/;"	f	namespace:ev	signature:()
async_pending	ev_wrap.h	107;"	d
async_pending	ev_wrap.h	8;"	d
asynccnt	ev_wrap.h	108;"	d
asynccnt	ev_wrap.h	9;"	d
asyncmax	ev_wrap.h	109;"	d
asyncmax	ev_wrap.h	10;"	d
asyncs	ev_wrap.h	110;"	d
asyncs	ev_wrap.h	11;"	d
at	ev.c	/^    ev_tstamp at;$/;"	m	struct:__anon8	file:	access:public
attr	ev.h	/^  ev_statdata attr;   \/* ro *\/$/;"	m	struct:ev_stat	access:public
backend	ev++.h	/^    unsigned int backend () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
backend	ev_wrap.h	111;"	d
backend	ev_wrap.h	12;"	d
backend_fd	ev_wrap.h	112;"	d
backend_fd	ev_wrap.h	13;"	d
backend_mintime	ev_wrap.h	113;"	d
backend_mintime	ev_wrap.h	14;"	d
backend_modify	ev_wrap.h	114;"	d
backend_modify	ev_wrap.h	15;"	d
backend_poll	ev_wrap.h	115;"	d
backend_poll	ev_wrap.h	16;"	d
bad_loop	ev++.h	/^    bad_loop ()$/;"	f	struct:ev::bad_loop	access:public	signature:()
bad_loop	ev++.h	/^  struct bad_loop$/;"	s	namespace:ev	inherits:std::runtime_error
base	ev++.h	/^    base (EV_PX) throw ()$/;"	f	struct:ev::base	access:public	signature:(EV_PX)
base	ev++.h	/^  struct base : ev_watcher$/;"	s	namespace:ev	inherits:ev_watcher
bindir	Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
break_loop	ev++.h	/^    void break_loop (how_t how = ONE) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(how_t how = ONE)
buffer	event_compat.h	/^	u_char *buffer;$/;"	m	struct:evbuffer	access:public
bufferevent	event_compat.h	/^struct bufferevent {$/;"	s
bufferevent::cbarg	event_compat.h	/^	void *cbarg;$/;"	m	struct:bufferevent	access:public
bufferevent::enabled	event_compat.h	/^	short enabled;	\/* events that are currently enabled *\/$/;"	m	struct:bufferevent	access:public
bufferevent::errorcb	event_compat.h	/^	everrorcb errorcb;$/;"	m	struct:bufferevent	access:public
bufferevent::ev_read	event_compat.h	/^	struct event ev_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
bufferevent::ev_write	event_compat.h	/^	struct event ev_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
bufferevent::input	event_compat.h	/^	struct evbuffer *input;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
bufferevent::output	event_compat.h	/^	struct evbuffer *output;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
bufferevent::readcb	event_compat.h	/^	evbuffercb readcb;$/;"	m	struct:bufferevent	access:public
bufferevent::timeout_read	event_compat.h	/^	int timeout_read;	\/* in seconds *\/$/;"	m	struct:bufferevent	access:public
bufferevent::timeout_write	event_compat.h	/^	int timeout_write;	\/* in seconds *\/$/;"	m	struct:bufferevent	access:public
bufferevent::wm_read	event_compat.h	/^	struct event_watermark wm_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
bufferevent::wm_write	event_compat.h	/^	struct event_watermark wm_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
bufferevent::writecb	event_compat.h	/^	evbuffercb writecb;$/;"	m	struct:bufferevent	access:public
bufferevent_base_set	event_compat.h	/^int bufferevent_base_set(struct event_base *base, struct bufferevent *bufev);$/;"	p	signature:(struct event_base *base, struct bufferevent *bufev)
bufferevent_disable	event_compat.h	/^int bufferevent_disable(struct bufferevent *bufev, short event);$/;"	p	signature:(struct bufferevent *bufev, short event)
bufferevent_enable	event_compat.h	/^int bufferevent_enable(struct bufferevent *bufev, short event);$/;"	p	signature:(struct bufferevent *bufev, short event)
bufferevent_free	event_compat.h	/^void bufferevent_free(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_new	event_compat.h	/^struct bufferevent *bufferevent_new(int fd,$/;"	p	signature:(int fd, evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg)
bufferevent_priority_set	event_compat.h	/^int bufferevent_priority_set(struct bufferevent *bufev, int pri);$/;"	p	signature:(struct bufferevent *bufev, int pri)
bufferevent_read	event_compat.h	/^size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);$/;"	p	signature:(struct bufferevent *bufev, void *data, size_t size)
bufferevent_settimeout	event_compat.h	/^void bufferevent_settimeout(struct bufferevent *bufev,$/;"	p	signature:(struct bufferevent *bufev, int timeout_read, int timeout_write)
bufferevent_write	event_compat.h	/^int bufferevent_write(struct bufferevent *bufev, const void *data, size_t size);$/;"	p	signature:(struct bufferevent *bufev, const void *data, size_t size)
bufferevent_write_buffer	event_compat.h	/^int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf);$/;"	p	signature:(struct bufferevent *bufev, struct evbuffer *buf)
build	Makefile	/^build = x86_64-unknown-linux-gnu$/;"	m
build_alias	Makefile	/^build_alias = $/;"	m
build_cpu	Makefile	/^build_cpu = x86_64$/;"	m
build_os	Makefile	/^build_os = linux-gnu$/;"	m
build_triplet	Makefile	/^build_triplet = x86_64-unknown-linux-gnu$/;"	m
build_vendor	Makefile	/^build_vendor = unknown$/;"	m
builddir	Makefile	/^builddir = .$/;"	m
cb	ev.c	/^  void (*cb)(int revents, void *arg);$/;"	m	struct:ev_once	file:	access:public
cb	event.c	/^  void (*cb)(int, short, void *);$/;"	m	struct:ev_x_once	file:	access:public
cb	event_compat.h	/^	void (*cb)(struct evbuffer *, size_t, size_t, void *);$/;"	m	struct:evbuffer	access:public
cbarg	event_compat.h	/^	void *cbarg;$/;"	m	struct:bufferevent	access:public
cbarg	event_compat.h	/^	void *cbarg;$/;"	m	struct:evbuffer	access:public
check	ev.h	/^  ev_check check;        \/* unused *\/$/;"	m	struct:ev_embed	access:public
check	ev.h	/^  struct ev_check check;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_check	access:public
checkcnt	ev_wrap.h	116;"	d
checkcnt	ev_wrap.h	17;"	d
checkmax	ev_wrap.h	117;"	d
checkmax	ev_wrap.h	18;"	d
checks	ev_wrap.h	118;"	d
checks	ev_wrap.h	19;"	d
child	ev.h	/^  struct ev_child child;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_child	access:public
child_reap	ev.c	/^child_reap (EV_P_ int chain, int pid, int status)$/;"	f	signature:(EV_P_ int chain, int pid, int status)
childcb	ev.c	/^childcb (EV_P_ ev_signal *sw, int revents)$/;"	f	file:	signature:(EV_P_ ev_signal *sw, int revents)
childev	ev.c	/^static ev_signal childev;$/;"	v	file:
childs	ev.c	/^static WL childs [EV_PID_HASHSIZE];$/;"	v	file:
cleanup	ev.h	/^  ev_cleanup cleanup;    \/* unused *\/$/;"	m	struct:ev_embed	access:public
cleanup	ev.h	/^  struct ev_cleanup cleanup;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_cleanup	access:public
cleanupcnt	ev_wrap.h	119;"	d
cleanupcnt	ev_wrap.h	20;"	d
cleanupmax	ev_wrap.h	120;"	d
cleanupmax	ev_wrap.h	21;"	d
cleanups	ev_wrap.h	121;"	d
cleanups	ev_wrap.h	22;"	d
clear_pending	ev.c	/^clear_pending (EV_P_ W w)$/;"	f	signature:(EV_P_ W w)
clock_gettime	ev.c	389;"	d	file:
curpid	ev_wrap.h	122;"	d
curpid	ev_wrap.h	23;"	d
dLOOPbase	event.c	52;"	d	file:
dLOOPbase	event.c	55;"	d	file:
dLOOPev	event.c	51;"	d	file:
dLOOPev	event.c	54;"	d	file:
datadir	Makefile	/^datadir = ${datarootdir}$/;"	m
datarootdir	Makefile	/^datarootdir = ${prefix}\/share$/;"	m
dealloc	event_compat.h	/^	void (*dealloc)(struct event_base *, void *);$/;"	m	struct:eventop	access:public
default_loop	ev++.h	/^    default_loop (const default_loop &);$/;"	p	struct:ev::default_loop	access:private	signature:(const default_loop &)
default_loop	ev++.h	/^    default_loop (unsigned int flags = AUTO) throw (bad_loop)$/;"	f	struct:ev::default_loop	access:public	signature:(unsigned int flags = AUTO)
default_loop	ev++.h	/^  struct default_loop : loop_ref$/;"	s	namespace:ev	inherits:loop_ref
default_loop_struct	ev.c	/^  static struct ev_loop default_loop_struct;$/;"	v	typeref:struct:ev_loop	file:
del	event_compat.h	/^	int (*del)(void *, struct event *);$/;"	m	struct:eventop	access:public
delay	ev++.h	/^  inline void delay (tstamp interval) throw ()$/;"	f	namespace:ev	signature:(tstamp interval)
depcomp	Makefile	/^depcomp = $(SHELL) $(top_srcdir)\/depcomp$/;"	m
depth	ev++.h	/^    unsigned int depth () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
dispatch	event_compat.h	/^	int (*dispatch)(struct event_base *, void *, struct timeval *);$/;"	m	struct:eventop	access:public
distcleancheck_listfiles	Makefile	/^distcleancheck_listfiles = find . -type f -print$/;"	m
distdir	Makefile	/^distdir = $(PACKAGE)-$(VERSION)$/;"	m
distuninstallcheck_listfiles	Makefile	/^distuninstallcheck_listfiles = find . -type f -print$/;"	m
docdir	Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE}$/;"	m
downheap	ev.c	/^downheap (ANHE *heap, int N, int k)$/;"	f	signature:(ANHE *heap, int N, int k)
dummy	event.c	/^  int dummy;$/;"	m	struct:event_base	file:	access:public
dvidir	Makefile	/^dvidir = ${docdir}$/;"	m
dynamic_loop	ev++.h	/^    dynamic_loop (const dynamic_loop &);$/;"	p	struct:ev::dynamic_loop	access:private	signature:(const dynamic_loop &)
dynamic_loop	ev++.h	/^    dynamic_loop (unsigned int flags = AUTO) throw (bad_loop)$/;"	f	struct:ev::dynamic_loop	access:public	signature:(unsigned int flags = AUTO)
dynamic_loop	ev++.h	/^  struct dynamic_loop : loop_ref$/;"	s	namespace:ev	inherits:loop_ref
ecb_array_length	ev.c	1097;"	d	file:
ecb_artificial	ev.c	838;"	d	file:
ecb_artificial	ev.c	842;"	d	file:
ecb_assume	ev.c	1034;"	d	file:
ecb_attribute	ev.c	796;"	d	file:
ecb_attribute	ev.c	801;"	d	file:
ecb_big_endian	ev.c	/^ecb_inline ecb_bool ecb_big_endian    (void) { return ecb_byteorder_helper () == 0x11; }$/;"	f	signature:(void)
ecb_binary16_to_float	ev.c	/^  ecb_binary16_to_float (uint16_t x)$/;"	f	signature:(uint16_t x)
ecb_binary32_to_float	ev.c	/^  ecb_binary32_to_float (uint32_t x)$/;"	f	signature:(uint32_t x)
ecb_binary64_to_double	ev.c	/^  ecb_binary64_to_double (uint64_t x)$/;"	f	signature:(uint64_t x)
ecb_bitrev16	ev.c	/^ecb_function_ uint16_t ecb_bitrev16 (uint16_t x)$/;"	f	signature:(uint16_t x)
ecb_bitrev32	ev.c	/^ecb_function_ uint32_t ecb_bitrev32 (uint32_t x)$/;"	f	signature:(uint32_t x)
ecb_bitrev8	ev.c	/^ecb_function_ uint8_t  ecb_bitrev8  (uint8_t  x)$/;"	f	signature:(uint8_t x)
ecb_bool	ev.c	/^typedef int ecb_bool;$/;"	t	file:
ecb_bswap16	ev.c	/^  ecb_bswap16 (uint16_t x)$/;"	f	signature:(uint16_t x)
ecb_bswap16	ev.c	999;"	d	file:
ecb_bswap32	ev.c	/^  ecb_bswap32 (uint32_t x)$/;"	f	signature:(uint32_t x)
ecb_bswap32	ev.c	1000;"	d	file:
ecb_bswap64	ev.c	/^  ecb_bswap64 (uint64_t x)$/;"	f	signature:(uint64_t x)
ecb_bswap64	ev.c	1001;"	d	file:
ecb_byteorder_helper	ev.c	/^ecb_byteorder_helper (void)$/;"	f	signature:(void)
ecb_cold	ev.c	840;"	d	file:
ecb_cold	ev.c	844;"	d	file:
ecb_const	ev.c	827;"	d	file:
ecb_ctz32	ev.c	/^  ecb_ctz32 (uint32_t x)$/;"	f	signature:(uint32_t x)
ecb_ctz32	ev.c	861;"	d	file:
ecb_ctz64	ev.c	/^  ecb_ctz64 (uint64_t x)$/;"	f	signature:(uint64_t x)
ecb_ctz64	ev.c	862;"	d	file:
ecb_decltype	ev.c	814;"	d	file:
ecb_decltype	ev.c	816;"	d	file:
ecb_deprecated	ev.c	820;"	d	file:
ecb_deprecated	ev.c	822;"	d	file:
ecb_div_rd	ev.c	/^  static inline T ecb_div_rd (T val, T div)$/;"	f	file:	signature:(T val, T div)
ecb_div_rd	ev.c	1085;"	d	file:
ecb_div_ru	ev.c	/^  static inline T ecb_div_ru (T val, T div)$/;"	f	file:	signature:(T val, T div)
ecb_div_ru	ev.c	1086;"	d	file:
ecb_double_to_binary64	ev.c	/^  ecb_double_to_binary64 (double x)$/;"	f	signature:(double x)
ecb_expect	ev.c	798;"	d	file:
ecb_expect	ev.c	808;"	d	file:
ecb_expect_false	ev.c	850;"	d	file:
ecb_expect_true	ev.c	851;"	d	file:
ecb_float_to_binary32	ev.c	/^  ecb_float_to_binary32 (float x)$/;"	f	signature:(float x)
ecb_function_	ev.c	793;"	d	file:
ecb_hot	ev.c	839;"	d	file:
ecb_hot	ev.c	843;"	d	file:
ecb_inline	ev.c	769;"	d	file:
ecb_inline	ev.c	771;"	d	file:
ecb_inline	ev.c	773;"	d	file:
ecb_inline	ev.c	775;"	d	file:
ecb_is_constant	ev.c	797;"	d	file:
ecb_is_constant	ev.c	807;"	d	file:
ecb_is_pot32	ev.c	/^ecb_function_ ecb_bool ecb_is_pot32 (uint32_t x) { return !(x & (x - 1)); }$/;"	f	signature:(uint32_t x)
ecb_is_pot64	ev.c	/^ecb_function_ ecb_bool ecb_is_pot64 (uint64_t x) { return !(x & (x - 1)); }$/;"	f	signature:(uint64_t x)
ecb_ld32	ev.c	/^  ecb_function_ int ecb_ld32 (uint32_t x)$/;"	f	signature:(uint32_t x)
ecb_ld32	ev.c	859;"	d	file:
ecb_ld64	ev.c	/^  ecb_function_ int ecb_ld64 (uint64_t x)$/;"	f	signature:(uint64_t x)
ecb_ld64	ev.c	860;"	d	file:
ecb_likely	ev.c	853;"	d	file:
ecb_little_endian	ev.c	/^ecb_inline ecb_bool ecb_little_endian (void) { return ecb_byteorder_helper () == 0x44; }$/;"	f	signature:(void)
ecb_mf_lock	ev.c	/^    static pthread_mutex_t ecb_mf_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
ecb_mod	ev.c	1068;"	d	file:
ecb_mod	ev.c	1070;"	d	file:
ecb_noinline	ev.c	825;"	d	file:
ecb_noreturn	ev.c	832;"	d	file:
ecb_noreturn	ev.c	834;"	d	file:
ecb_popcount32	ev.c	/^  ecb_popcount32 (uint32_t x)$/;"	f	signature:(uint32_t x)
ecb_popcount32	ev.c	863;"	d	file:
ecb_popcount64	ev.c	/^ecb_popcount64 (uint64_t x)$/;"	f	signature:(uint64_t x)
ecb_prefetch	ev.c	799;"	d	file:
ecb_prefetch	ev.c	809;"	d	file:
ecb_pure	ev.c	828;"	d	file:
ecb_restrict	ev.c	779;"	d	file:
ecb_restrict	ev.c	781;"	d	file:
ecb_restrict	ev.c	783;"	d	file:
ecb_rotl16	ev.c	/^ecb_inline uint16_t ecb_rotl16 (uint16_t x, unsigned int count) { return (x >> (16 - count)) | (x << count); }$/;"	f	signature:(uint16_t x, unsigned int count)
ecb_rotl32	ev.c	/^ecb_inline uint32_t ecb_rotl32 (uint32_t x, unsigned int count) { return (x >> (32 - count)) | (x << count); }$/;"	f	signature:(uint32_t x, unsigned int count)
ecb_rotl64	ev.c	/^ecb_inline uint64_t ecb_rotl64 (uint64_t x, unsigned int count) { return (x >> (64 - count)) | (x << count); }$/;"	f	signature:(uint64_t x, unsigned int count)
ecb_rotl8	ev.c	/^ecb_inline uint8_t  ecb_rotl8  (uint8_t  x, unsigned int count) { return (x >> ( 8 - count)) | (x << count); }$/;"	f	signature:(uint8_t x, unsigned int count)
ecb_rotr16	ev.c	/^ecb_inline uint16_t ecb_rotr16 (uint16_t x, unsigned int count) { return (x << (16 - count)) | (x >> count); }$/;"	f	signature:(uint16_t x, unsigned int count)
ecb_rotr32	ev.c	/^ecb_inline uint32_t ecb_rotr32 (uint32_t x, unsigned int count) { return (x << (32 - count)) | (x >> count); }$/;"	f	signature:(uint32_t x, unsigned int count)
ecb_rotr64	ev.c	/^ecb_inline uint64_t ecb_rotr64 (uint64_t x, unsigned int count) { return (x << (64 - count)) | (x >> count); }$/;"	f	signature:(uint64_t x, unsigned int count)
ecb_rotr8	ev.c	/^ecb_inline uint8_t  ecb_rotr8  (uint8_t  x, unsigned int count) { return (x << ( 8 - count)) | (x >> count); }$/;"	f	signature:(uint8_t x, unsigned int count)
ecb_unlikely	ev.c	854;"	d	file:
ecb_unreachable	ev.c	/^  ecb_inline void ecb_unreachable (void) { }$/;"	f	signature:(void)
ecb_unreachable	ev.c	1026;"	d	file:
ecb_unused	ev.c	826;"	d	file:
egen	ev.c	/^  unsigned int egen;    \/* generation counter to counter epoll bugs *\/$/;"	m	struct:__anon5	file:	access:public
emask	ev.c	/^  unsigned char emask;  \/* the epoll backend stores the actual kernel mask in here *\/$/;"	m	struct:__anon5	file:	access:public
embed	ev.h	/^  struct ev_embed embed;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_embed	access:public
embed_fork_cb	ev.c	/^embed_fork_cb (EV_P_ ev_fork *fork_w, int revents)$/;"	f	file:	signature:(EV_P_ ev_fork *fork_w, int revents)
embed_io_cb	ev.c	/^embed_io_cb (EV_P_ ev_io *io, int revents)$/;"	f	file:	signature:(EV_P_ ev_io *io, int revents)
embed_prepare_cb	ev.c	/^embed_prepare_cb (EV_P_ ev_prepare *prepare, int revents)$/;"	f	file:	signature:(EV_P_ ev_prepare *prepare, int revents)
embeddable_backends	ev++.h	/^  inline unsigned int embeddable_backends () throw ()$/;"	f	namespace:ev	signature:()
enable_secure	ev.c	/^enable_secure (void)$/;"	f	signature:(void)
enabled	event_compat.h	/^	short enabled;	\/* events that are currently enabled *\/$/;"	m	struct:bufferevent	access:public
encode_int	event_compat.h	/^void encode_int(struct evbuffer *evbuf, uint32_t number);$/;"	p	signature:(struct evbuffer *evbuf, uint32_t number)
epoll_destroy	ev_epoll.c	/^epoll_destroy (EV_P)$/;"	f
epoll_epermcnt	ev_wrap.h	123;"	d
epoll_epermcnt	ev_wrap.h	24;"	d
epoll_epermmax	ev_wrap.h	124;"	d
epoll_epermmax	ev_wrap.h	25;"	d
epoll_eperms	ev_wrap.h	125;"	d
epoll_eperms	ev_wrap.h	26;"	d
epoll_eventmax	ev_wrap.h	126;"	d
epoll_eventmax	ev_wrap.h	27;"	d
epoll_events	ev_wrap.h	127;"	d
epoll_events	ev_wrap.h	28;"	d
epoll_fork	ev_epoll.c	/^epoll_fork (EV_P)$/;"	f
epoll_init	ev_epoll.c	/^epoll_init (EV_P_ int flags)$/;"	f	signature:(EV_P_ int flags)
epoll_modify	ev_epoll.c	/^epoll_modify (EV_P_ int fd, int oev, int nev)$/;"	f	file:	signature:(EV_P_ int fd, int oev, int nev)
epoll_poll	ev_epoll.c	/^epoll_poll (EV_P_ ev_tstamp timeout)$/;"	f	file:	signature:(EV_P_ ev_tstamp timeout)
errorcb	event_compat.h	/^	everrorcb errorcb;$/;"	m	struct:bufferevent	access:public
ev	ev++.h	/^namespace ev {$/;"	n
ev::ALL	ev++.h	/^    ALL = EVBREAK_ALL$/;"	e	enum:ev::how_t
ev::ASYNC	ev++.h	/^    ASYNC    = EV_ASYNC,$/;"	e	enum:ev::__anon1
ev::AUTO	ev++.h	/^    AUTO      = EVFLAG_AUTO,$/;"	e	enum:ev::__anon2
ev::CHECK	ev++.h	/^    CHECK    = EV_CHECK,$/;"	e	enum:ev::__anon1
ev::CHILD	ev++.h	/^    CHILD    = EV_CHILD,$/;"	e	enum:ev::__anon1
ev::DEVPOLL	ev++.h	/^    DEVPOLL   = EVBACKEND_DEVPOLL,$/;"	e	enum:ev::__anon2
ev::EMBED	ev++.h	/^    EMBED    = EV_EMBED,$/;"	e	enum:ev::__anon1
ev::EPOLL	ev++.h	/^    EPOLL     = EVBACKEND_EPOLL,$/;"	e	enum:ev::__anon2
ev::ERROR	ev++.h	/^    ERROR    = EV_ERROR$/;"	e	enum:ev::__anon1
ev::FORK	ev++.h	/^    FORK     = EV_FORK,$/;"	e	enum:ev::__anon1
ev::FORKCHECK	ev++.h	/^    FORKCHECK = EVFLAG_FORKCHECK,$/;"	e	enum:ev::__anon2
ev::IDLE	ev++.h	/^    IDLE     = EV_IDLE,$/;"	e	enum:ev::__anon1
ev::KQUEUE	ev++.h	/^    KQUEUE    = EVBACKEND_KQUEUE,$/;"	e	enum:ev::__anon2
ev::NOENV	ev++.h	/^    NOENV     = EVFLAG_NOENV,$/;"	e	enum:ev::__anon2
ev::NONBLOCK	ev++.h	/^    NONBLOCK = EVLOOP_NONBLOCK,$/;"	e	enum:ev::__anon3
ev::NONE	ev++.h	/^    NONE     = EV_NONE,$/;"	e	enum:ev::__anon1
ev::NOWAIT	ev++.h	/^    NOWAIT   = EVRUN_NOWAIT,$/;"	e	enum:ev::__anon3
ev::ONCE	ev++.h	/^    ONCE     = EVRUN_ONCE$/;"	e	enum:ev::__anon3
ev::ONE	ev++.h	/^    ONE = EVBREAK_ONE,$/;"	e	enum:ev::how_t
ev::ONESHOT	ev++.h	/^    ONESHOT  = EVLOOP_ONESHOT,$/;"	e	enum:ev::__anon3
ev::PERIODIC	ev++.h	/^    PERIODIC = EV_PERIODIC,$/;"	e	enum:ev::__anon1
ev::POLL	ev++.h	/^    POLL      = EVBACKEND_POLL,$/;"	e	enum:ev::__anon2
ev::PORT	ev++.h	/^    PORT      = EVBACKEND_PORT$/;"	e	enum:ev::__anon2
ev::PREPARE	ev++.h	/^    PREPARE  = EV_PREPARE,$/;"	e	enum:ev::__anon1
ev::READ	ev++.h	/^    READ     = EV_READ,$/;"	e	enum:ev::__anon1
ev::SELECT	ev++.h	/^    SELECT    = EVBACKEND_SELECT,$/;"	e	enum:ev::__anon2
ev::SIGNAL	ev++.h	/^    SIGNAL   = EV_SIGNAL,$/;"	e	enum:ev::__anon1
ev::STAT	ev++.h	/^    STAT     = EV_STAT,$/;"	e	enum:ev::__anon1
ev::TIMEOUT	ev++.h	/^    TIMEOUT  = EV_TIMEOUT,$/;"	e	enum:ev::__anon1
ev::TIMER	ev++.h	/^    TIMER    = EV_TIMER,$/;"	e	enum:ev::__anon1
ev::UNDEF	ev++.h	/^    UNDEF    = EV_UNDEF,$/;"	e	enum:ev::__anon1
ev::WRITE	ev++.h	/^    WRITE    = EV_WRITE,$/;"	e	enum:ev::__anon1
ev::again	ev++.h	/^    void again () throw ()$/;"	f	namespace:ev	signature:()
ev::async_pending	ev++.h	/^    bool async_pending () throw ()$/;"	f	namespace:ev	signature:()
ev::bad_loop	ev++.h	/^  struct bad_loop$/;"	s	namespace:ev	inherits:std::runtime_error
ev::bad_loop::bad_loop	ev++.h	/^    bad_loop ()$/;"	f	struct:ev::bad_loop	access:public	signature:()
ev::base	ev++.h	/^  struct base : ev_watcher$/;"	s	namespace:ev	inherits:ev_watcher
ev::base::EV_PX	ev++.h	/^      EV_PX;$/;"	m	struct:ev::base	access:public
ev::base::base	ev++.h	/^    base (EV_PX) throw ()$/;"	f	struct:ev::base	access:public	signature:(EV_PX)
ev::base::feed_event	ev++.h	/^    void feed_event (int revents) throw ()$/;"	f	struct:ev::base	access:public	signature:(int revents)
ev::base::function_thunk	ev++.h	/^    static void function_thunk (EV_P_ ev_watcher *w, int revents)$/;"	f	struct:ev::base	access:public	signature:(EV_P_ ev_watcher *w, int revents)
ev::base::is_active	ev++.h	/^    bool is_active () const throw ()$/;"	f	struct:ev::base	access:public	signature:() const
ev::base::is_pending	ev++.h	/^    bool is_pending () const throw ()$/;"	f	struct:ev::base	access:public	signature:() const
ev::base::method_noargs_thunk	ev++.h	/^    static void method_noargs_thunk (EV_P_ ev_watcher *w, int revents)$/;"	f	struct:ev::base	access:public	signature:(EV_P_ ev_watcher *w, int revents)
ev::base::method_thunk	ev++.h	/^    static void method_thunk (EV_P_ ev_watcher *w, int revents)$/;"	f	struct:ev::base	access:public	signature:(EV_P_ ev_watcher *w, int revents)
ev::base::operator ()	ev++.h	/^    void operator ()(int events = EV_UNDEF)$/;"	f	struct:ev::base	access:public	signature:(int events = EV_UNDEF)
ev::base::set	ev++.h	/^      void set (EV_P) throw ()$/;"	f	struct:ev::base	access:public	signature:(EV_P)
ev::base::set	ev++.h	/^    void set (K *object) throw ()$/;"	f	struct:ev::base	access:public	signature:(K *object)
ev::base::set	ev++.h	/^    void set (void *data = 0) throw ()$/;"	f	struct:ev::base	access:public	signature:(void *data = 0)
ev::base::set_	ev++.h	/^    void set_ (const void *data, void (*cb)(EV_P_ ev_watcher *w, int revents)) throw ()$/;"	f	struct:ev::base	access:public	signature:(const void *data, void (*cb)(EV_P_ ev_watcher *w, int revents))
ev::default_loop	ev++.h	/^  struct default_loop : loop_ref$/;"	s	namespace:ev	inherits:loop_ref
ev::default_loop::default_loop	ev++.h	/^    default_loop (const default_loop &);$/;"	p	struct:ev::default_loop	access:private	signature:(const default_loop &)
ev::default_loop::default_loop	ev++.h	/^    default_loop (unsigned int flags = AUTO) throw (bad_loop)$/;"	f	struct:ev::default_loop	access:public	signature:(unsigned int flags = AUTO)
ev::default_loop::operator =	ev++.h	/^    default_loop &operator = (const default_loop &);$/;"	p	struct:ev::default_loop	access:private	signature:(const default_loop &)
ev::delay	ev++.h	/^  inline void delay (tstamp interval) throw ()$/;"	f	namespace:ev	signature:(tstamp interval)
ev::dynamic_loop	ev++.h	/^  struct dynamic_loop : loop_ref$/;"	s	namespace:ev	inherits:loop_ref
ev::dynamic_loop::dynamic_loop	ev++.h	/^    dynamic_loop (const dynamic_loop &);$/;"	p	struct:ev::dynamic_loop	access:private	signature:(const dynamic_loop &)
ev::dynamic_loop::dynamic_loop	ev++.h	/^    dynamic_loop (unsigned int flags = AUTO) throw (bad_loop)$/;"	f	struct:ev::dynamic_loop	access:public	signature:(unsigned int flags = AUTO)
ev::dynamic_loop::operator =	ev++.h	/^    dynamic_loop & operator= (const dynamic_loop &);$/;"	p	struct:ev::dynamic_loop	access:private	signature:(const dynamic_loop &)
ev::dynamic_loop::~dynamic_loop	ev++.h	/^    ~dynamic_loop () throw ()$/;"	f	struct:ev::dynamic_loop	access:public	signature:()
ev::embeddable_backends	ev++.h	/^  inline unsigned int embeddable_backends () throw ()$/;"	f	namespace:ev	signature:()
ev::get_default_loop	ev++.h	/^  inline loop_ref get_default_loop () throw ()$/;"	f	namespace:ev	signature:()
ev::how_t	ev++.h	/^  enum how_t$/;"	g	namespace:ev
ev::loop_ref	ev++.h	/^  struct loop_ref$/;"	s	namespace:ev
ev::loop_ref::EV_AX	ev++.h	/^    struct ev_loop* EV_AX;$/;"	m	struct:ev::loop_ref	typeref:struct:ev::loop_ref::ev_loop	access:public
ev::loop_ref::backend	ev++.h	/^    unsigned int backend () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
ev::loop_ref::break_loop	ev++.h	/^    void break_loop (how_t how = ONE) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(how_t how = ONE)
ev::loop_ref::depth	ev++.h	/^    unsigned int depth () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
ev::loop_ref::feed_fd_event	ev++.h	/^    void feed_fd_event (int fd, int revents) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(int fd, int revents)
ev::loop_ref::feed_signal_event	ev++.h	/^    void feed_signal_event (int signum) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(int signum)
ev::loop_ref::is_default	ev++.h	/^    bool is_default () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
ev::loop_ref::iteration	ev++.h	/^    unsigned int iteration () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
ev::loop_ref::loop	ev++.h	/^    void loop (int flags = 0)$/;"	f	struct:ev::loop_ref	access:public	signature:(int flags = 0)
ev::loop_ref::loop_ref	ev++.h	/^    loop_ref (EV_P) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(EV_P)
ev::loop_ref::method_noargs_thunk	ev++.h	/^    static void method_noargs_thunk (int revents, void *arg)$/;"	f	struct:ev::loop_ref	access:public	signature:(int revents, void *arg)
ev::loop_ref::method_thunk	ev++.h	/^    static void method_thunk (int revents, void *arg)$/;"	f	struct:ev::loop_ref	access:public	signature:(int revents, void *arg)
ev::loop_ref::now	ev++.h	/^    tstamp now () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
ev::loop_ref::once	ev++.h	/^    void once (int fd, int events, tstamp timeout) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(int fd, int events, tstamp timeout)
ev::loop_ref::once	ev++.h	/^    void once (int fd, int events, tstamp timeout, K *object) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(int fd, int events, tstamp timeout, K *object)
ev::loop_ref::once	ev++.h	/^    void once (int fd, int events, tstamp timeout, void (*cb)(int, void *), void *arg = 0) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(int fd, int events, tstamp timeout, void (*cb)(int, void *), void *arg = 0)
ev::loop_ref::operator !=	ev++.h	/^    bool operator != (const EV_P) const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(const EV_P) const
ev::loop_ref::operator !=	ev++.h	/^    bool operator != (const loop_ref &other) const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(const loop_ref &other) const
ev::loop_ref::operator ==	ev++.h	/^    bool operator == (const EV_P) const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(const EV_P) const
ev::loop_ref::operator ==	ev++.h	/^    bool operator == (const loop_ref &other) const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(const loop_ref &other) const
ev::loop_ref::operator const struct ev_loop *	ev++.h	/^    operator const struct ev_loop * () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
ev::loop_ref::operator struct ev_loop *	ev++.h	/^    operator struct ev_loop * () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
ev::loop_ref::post_fork	ev++.h	/^    void post_fork () throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:()
ev::loop_ref::ref	ev++.h	/^    void ref () throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:()
ev::loop_ref::run	ev++.h	/^    void run (int flags = 0)$/;"	f	struct:ev::loop_ref	access:public	signature:(int flags = 0)
ev::loop_ref::set_io_collect_interval	ev++.h	/^    void set_io_collect_interval (tstamp interval) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(tstamp interval)
ev::loop_ref::set_timeout_collect_interval	ev++.h	/^    void set_timeout_collect_interval (tstamp interval) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(tstamp interval)
ev::loop_ref::simpler_func_thunk	ev++.h	/^    static void simpler_func_thunk (int revents, void *arg)$/;"	f	struct:ev::loop_ref	access:public	signature:(int revents, void *arg)
ev::loop_ref::simplest_func_thunk	ev++.h	/^    static void simplest_func_thunk (int revents, void *arg)$/;"	f	struct:ev::loop_ref	access:public	signature:(int revents, void *arg)
ev::loop_ref::unloop	ev++.h	/^    void unloop (how_t how = ONE) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(how_t how = ONE)
ev::loop_ref::unref	ev++.h	/^    void unref () throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:()
ev::now	ev++.h	/^  inline tstamp now (EV_P) throw ()$/;"	f	namespace:ev	signature:(EV_P)
ev::recommended_backends	ev++.h	/^  inline unsigned int recommended_backends () throw ()$/;"	f	namespace:ev	signature:()
ev::remaining	ev++.h	/^    ev_tstamp remaining ()$/;"	f	namespace:ev	signature:()
ev::send	ev++.h	/^    void send () throw ()$/;"	f	namespace:ev	signature:()
ev::set	ev++.h	/^    void set () throw () { }$/;"	f	namespace:ev	signature:()
ev::set	ev++.h	/^    void set (const char *path, ev_tstamp interval = 0.) throw ()$/;"	f	namespace:ev	signature:(const char *path, ev_tstamp interval = 0.)
ev::set	ev++.h	/^    void set (ev_tstamp after, ev_tstamp repeat = 0.) throw ()$/;"	f	namespace:ev	signature:(ev_tstamp after, ev_tstamp repeat = 0.)
ev::set	ev++.h	/^    void set (ev_tstamp at, ev_tstamp interval = 0.) throw ()$/;"	f	namespace:ev	signature:(ev_tstamp at, ev_tstamp interval = 0.)
ev::set	ev++.h	/^    void set (int events) throw ()$/;"	f	namespace:ev	signature:(int events)
ev::set	ev++.h	/^    void set (int fd, int events) throw ()$/;"	f	namespace:ev	signature:(int fd, int events)
ev::set	ev++.h	/^    void set (int pid, int trace = 0) throw ()$/;"	f	namespace:ev	signature:(int pid, int trace = 0)
ev::set	ev++.h	/^    void set (int signum) throw ()$/;"	f	namespace:ev	signature:(int signum)
ev::set_allocator	ev++.h	/^  inline void set_allocator (void *(*cb)(void *ptr, long size) throw ()) throw ()$/;"	f	namespace:ev	signature:(void *(*cb)(void *ptr, long size) throw ())
ev::set_embed	ev++.h	/^    void set_embed (struct ev_loop *embedded_loop) throw ()$/;"	f	namespace:ev	signature:(struct ev_loop *embedded_loop)
ev::set_syserr_cb	ev++.h	/^  inline void set_syserr_cb (void (*cb)(const char *msg) throw ()) throw ()$/;"	f	namespace:ev	signature:(void (*cb)(const char *msg) throw ())
ev::start	ev++.h	/^    void start (const char *path, ev_tstamp interval = 0.) throw ()$/;"	f	namespace:ev	signature:(const char *path, ev_tstamp interval = 0.)
ev::start	ev++.h	/^    void start (ev_tstamp after, ev_tstamp repeat = 0.) throw ()$/;"	f	namespace:ev	signature:(ev_tstamp after, ev_tstamp repeat = 0.)
ev::start	ev++.h	/^    void start (ev_tstamp at, ev_tstamp interval = 0.) throw ()$/;"	f	namespace:ev	signature:(ev_tstamp at, ev_tstamp interval = 0.)
ev::start	ev++.h	/^    void start (int fd, int events) throw ()$/;"	f	namespace:ev	signature:(int fd, int events)
ev::start	ev++.h	/^    void start (int pid, int trace = 0) throw ()$/;"	f	namespace:ev	signature:(int pid, int trace = 0)
ev::start	ev++.h	/^    void start (int signum) throw ()$/;"	f	namespace:ev	signature:(int signum)
ev::start	ev++.h	/^    void start (struct ev_loop *embedded_loop) throw ()$/;"	f	namespace:ev	signature:(struct ev_loop *embedded_loop)
ev::supported_backends	ev++.h	/^  inline unsigned int supported_backends () throw ()$/;"	f	namespace:ev	signature:()
ev::sweep	ev++.h	/^    void sweep ()$/;"	f	namespace:ev	signature:()
ev::tstamp	ev++.h	/^  typedef ev_tstamp tstamp;$/;"	t	namespace:ev
ev::update	ev++.h	/^    void update () throw ()$/;"	f	namespace:ev	signature:()
ev::version_major	ev++.h	/^  inline int version_major () throw ()$/;"	f	namespace:ev	signature:()
ev::version_minor	ev++.h	/^  inline int version_minor () throw ()$/;"	f	namespace:ev	signature:()
ev_active	ev.c	1350;"	d	file:
ev_any_watcher	ev.h	/^union ev_any_watcher$/;"	u
ev_any_watcher::async	ev.h	/^  struct ev_async async;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_async	access:public
ev_any_watcher::check	ev.h	/^  struct ev_check check;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_check	access:public
ev_any_watcher::child	ev.h	/^  struct ev_child child;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_child	access:public
ev_any_watcher::cleanup	ev.h	/^  struct ev_cleanup cleanup;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_cleanup	access:public
ev_any_watcher::embed	ev.h	/^  struct ev_embed embed;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_embed	access:public
ev_any_watcher::fork	ev.h	/^  struct ev_fork fork;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_fork	access:public
ev_any_watcher::idle	ev.h	/^  struct ev_idle idle;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_idle	access:public
ev_any_watcher::io	ev.h	/^  struct ev_io io;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_io	access:public
ev_any_watcher::periodic	ev.h	/^  struct ev_periodic periodic;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_periodic	access:public
ev_any_watcher::prepare	ev.h	/^  struct ev_prepare prepare;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_prepare	access:public
ev_any_watcher::signal	ev.h	/^  struct ev_signal signal;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_signal	access:public
ev_any_watcher::stat	ev.h	/^  struct ev_stat stat;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_stat	access:public
ev_any_watcher::timer	ev.h	/^  struct ev_timer timer;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_timer	access:public
ev_any_watcher::w	ev.h	/^  struct ev_watcher w;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_watcher	access:public
ev_any_watcher::wl	ev.h	/^  struct ev_watcher_list wl;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_watcher_list	access:public
ev_arg	event.h	/^  void *ev_arg;$/;"	m	struct:event	access:public
ev_async	ev.h	/^typedef struct ev_async$/;"	s
ev_async	ev.h	/^} ev_async;$/;"	t	typeref:struct:ev_async
ev_async::sent	ev.h	/^  EV_ATOMIC_T sent; \/* private *\/$/;"	m	struct:ev_async	access:public
ev_async_init	ev.h	717;"	d
ev_async_pending	ev.h	462;"	d
ev_async_set	ev.h	703;"	d
ev_at	ev.c	1351;"	d	file:
ev_backend	ev.c	/^ev_backend (EV_P) EV_THROW$/;"	f
ev_base	event.h	/^  struct event_base *ev_base;$/;"	m	struct:event	typeref:struct:event::event_base	access:public
ev_callback	event.h	/^  event_callback_fn ev_callback;$/;"	m	struct:event	access:public
ev_cb	ev.h	722;"	d
ev_check	ev.h	/^typedef struct ev_check$/;"	s
ev_check	ev.h	/^} ev_check;$/;"	t	typeref:struct:ev_check
ev_check_2625	ev.c	/^ev_check_2625 (EV_P)$/;"	f
ev_check_init	ev.h	713;"	d
ev_check_set	ev.h	699;"	d
ev_child	ev.h	/^typedef struct ev_child$/;"	s
ev_child	ev.h	/^} ev_child;$/;"	t	typeref:struct:ev_child
ev_child::flags	ev.h	/^  int flags;   \/* private *\/$/;"	m	struct:ev_child	access:public
ev_child::pid	ev.h	/^  int pid;     \/* ro *\/$/;"	m	struct:ev_child	access:public
ev_child::rpid	ev.h	/^  int rpid;    \/* rw, holds the received pid *\/$/;"	m	struct:ev_child	access:public
ev_child::rstatus	ev.h	/^  int rstatus; \/* rw, holds the exit status, use the macros from sys\/wait.h *\/$/;"	m	struct:ev_child	access:public
ev_child_init	ev.h	709;"	d
ev_child_set	ev.h	695;"	d
ev_cleanup	ev.h	/^typedef struct ev_cleanup$/;"	s
ev_cleanup	ev.h	/^} ev_cleanup;$/;"	t	typeref:struct:ev_cleanup
ev_cleanup_init	ev.h	716;"	d
ev_cleanup_set	ev.h	702;"	d
ev_default_destroy	ev.h	/^    EV_INLINE void ev_default_destroy (void) { ev_loop_destroy (EV_DEFAULT); }$/;"	f	signature:(void)
ev_default_fork	ev.h	/^    EV_INLINE void ev_default_fork    (void) { ev_loop_fork    (EV_DEFAULT); }$/;"	f	signature:(void)
ev_default_loop_ptr	ev.c	/^  EV_API_DECL struct ev_loop *ev_default_loop_ptr = 0; \/* needs to be initialised to make it a definition despite extern *\/$/;"	v	typeref:struct:ev_loop
ev_default_loop_ptr	ev.c	/^  static int ev_default_loop_ptr;$/;"	v	file:
ev_default_loop_ptr	ev.h	/^EV_API_DECL struct ev_loop *ev_default_loop_ptr;$/;"	v	typeref:struct:ev_loop
ev_depth	ev.c	/^ev_depth (EV_P) EV_THROW$/;"	f
ev_embed	ev.h	/^typedef struct ev_embed$/;"	s
ev_embed	ev.h	/^} ev_embed;$/;"	t	typeref:struct:ev_embed
ev_embed::check	ev.h	/^  ev_check check;        \/* unused *\/$/;"	m	struct:ev_embed	access:public
ev_embed::cleanup	ev.h	/^  ev_cleanup cleanup;    \/* unused *\/$/;"	m	struct:ev_embed	access:public
ev_embed::fork	ev.h	/^  ev_fork fork;          \/* private *\/$/;"	m	struct:ev_embed	access:public
ev_embed::idle	ev.h	/^  ev_idle idle;          \/* unused *\/$/;"	m	struct:ev_embed	access:public
ev_embed::io	ev.h	/^  ev_io io;              \/* private *\/$/;"	m	struct:ev_embed	access:public
ev_embed::other	ev.h	/^  struct ev_loop *other; \/* ro *\/$/;"	m	struct:ev_embed	typeref:struct:ev_embed::ev_loop	access:public
ev_embed::periodic	ev.h	/^  ev_periodic periodic;  \/* unused *\/$/;"	m	struct:ev_embed	access:public
ev_embed::prepare	ev.h	/^  ev_prepare prepare;    \/* private *\/$/;"	m	struct:ev_embed	access:public
ev_embed::timer	ev.h	/^  ev_timer timer;        \/* unused *\/$/;"	m	struct:ev_embed	access:public
ev_embed_init	ev.h	714;"	d
ev_embed_set	ev.h	700;"	d
ev_events	event.h	/^  short ev_events;$/;"	m	struct:event	access:public
ev_fd	event.h	/^  int ev_fd;$/;"	m	struct:event	access:public
ev_flags	event.h	/^  int ev_flags;$/;"	m	struct:event	access:public
ev_floor	ev.c	/^ev_floor (ev_tstamp v)$/;"	f	file:	signature:(ev_tstamp v)
ev_floor	ev.c	1383;"	d	file:
ev_fork	ev.h	/^typedef struct ev_fork$/;"	s
ev_fork	ev.h	/^} ev_fork;$/;"	t	typeref:struct:ev_fork
ev_fork_init	ev.h	715;"	d
ev_fork_set	ev.h	701;"	d
ev_free	ev.c	1551;"	d	file:
ev_idle	ev.h	/^typedef struct ev_idle$/;"	s
ev_idle	ev.h	/^} ev_idle;$/;"	t	typeref:struct:ev_idle
ev_idle_init	ev.h	711;"	d
ev_idle_set	ev.h	697;"	d
ev_init	ev.h	684;"	d
ev_invoke	ev.c	/^ev_invoke (EV_P_ void *w, int revents)$/;"	f	signature:(EV_P_ void *w, int revents)
ev_invoke	ev.h	/^EV_API_DECL void ev_invoke         (EV_P_ void *w, int revents);$/;"	p	signature:(EV_P_ void *w, int revents)
ev_invoke_pending	ev.c	/^ev_invoke_pending (EV_P)$/;"	f
ev_invoke_pending	ev.h	/^EV_API_DECL void ev_invoke_pending (EV_P); \/* invoke all pending watchers *\/$/;"	p	signature:(EV_P)
ev_io	ev.h	/^typedef struct ev_io$/;"	s
ev_io	ev.h	/^} ev_io;$/;"	t	typeref:struct:ev_io
ev_io::events	ev.h	/^  int events; \/* ro *\/$/;"	m	struct:ev_io	access:public
ev_io::fd	ev.h	/^  int fd;     \/* ro *\/$/;"	m	struct:ev_io	access:public
ev_io_init	ev.h	705;"	d
ev_io_set	ev.h	691;"	d
ev_is_active	ev.h	720;"	d
ev_is_pending	ev.h	719;"	d
ev_iteration	ev.c	/^ev_iteration (EV_P) EV_THROW$/;"	f
ev_linux_version	ev.c	/^ev_linux_version (void)$/;"	f	file:	signature:(void)
ev_loop	ev.c	/^  struct ev_loop$/;"	s	file:
ev_loop	ev.h	/^    EV_INLINE void ev_loop   (EV_P_ int flags) { ev_run   (EV_A_ flags); }$/;"	f	signature:(EV_P_ int flags)
ev_loop	ev.h	/^  typedef struct ev_loop ev_loop;$/;"	t	typeref:struct:ev_loop
ev_loop::ev_rt_now	ev.c	/^    ev_tstamp ev_rt_now;$/;"	m	struct:ev_loop	file:	access:public
ev_loop_callback	ev.h	/^typedef void (*ev_loop_callback)(EV_P);$/;"	t
ev_loop_count	ev.h	/^      EV_INLINE unsigned int ev_loop_count  (EV_P) { return ev_iteration  (EV_A); }$/;"	f	signature:(EV_P)
ev_loop_depth	ev.h	/^      EV_INLINE unsigned int ev_loop_depth  (EV_P) { return ev_depth      (EV_A); }$/;"	f	signature:(EV_P)
ev_loop_destroy	ev.c	/^ev_loop_destroy (EV_P)$/;"	f
ev_loop_destroy	ev.h	/^EV_API_DECL void ev_loop_destroy (EV_P);$/;"	p	signature:(EV_P)
ev_loop_fork	ev.c	/^ev_loop_fork (EV_P) EV_THROW$/;"	f
ev_loop_verify	ev.h	/^      EV_INLINE void         ev_loop_verify (EV_P) {        ev_verify     (EV_A); }$/;"	f	signature:(EV_P)
ev_malloc	ev.c	1550;"	d	file:
ev_now	ev.c	/^ev_now (EV_P) EV_THROW$/;"	f
ev_now_update	ev.c	/^ev_now_update (EV_P) EV_THROW$/;"	f
ev_once	ev.c	/^struct ev_once$/;"	s	file:
ev_once::arg	ev.c	/^  void *arg;$/;"	m	struct:ev_once	file:	access:public
ev_once::cb	ev.c	/^  void (*cb)(int revents, void *arg);$/;"	m	struct:ev_once	file:	access:public
ev_once::io	ev.c	/^  ev_io io;$/;"	m	struct:ev_once	file:	access:public
ev_once::to	ev.c	/^  ev_timer to;$/;"	m	struct:ev_once	file:	access:public
ev_pending_count	ev.c	/^ev_pending_count (EV_P) EV_THROW$/;"	f
ev_periodic	ev.h	/^typedef struct ev_periodic$/;"	s
ev_periodic	ev.h	/^} ev_periodic;$/;"	t	typeref:struct:ev_periodic
ev_periodic::EV_THROW	ev.h	/^  ev_tstamp (*reschedule_cb)(struct ev_periodic *w, ev_tstamp now) EV_THROW; \/* rw *\/$/;"	m	struct:ev_periodic	access:public
ev_periodic::interval	ev.h	/^  ev_tstamp interval; \/* rw *\/$/;"	m	struct:ev_periodic	access:public
ev_periodic::offset	ev.h	/^  ev_tstamp offset; \/* rw *\/$/;"	m	struct:ev_periodic	access:public
ev_periodic_at	ev.h	732;"	d
ev_periodic_init	ev.h	707;"	d
ev_periodic_set	ev.h	693;"	d
ev_pipe	ev_win32.c	/^ev_pipe (int filedes [2])$/;"	f	file:	signature:(int filedes [2])
ev_prepare	ev.h	/^typedef struct ev_prepare$/;"	s
ev_prepare	ev.h	/^} ev_prepare;$/;"	t	typeref:struct:ev_prepare
ev_prepare_init	ev.h	712;"	d
ev_prepare_set	ev.h	698;"	d
ev_pri	event.h	/^  int ev_pri;$/;"	m	struct:event	access:public
ev_printerr	ev.c	/^ev_printerr (const char *msg)$/;"	f	file:	signature:(const char *msg)
ev_priority	ev.h	725;"	d
ev_priority	ev.h	728;"	d
ev_read	event_compat.h	/^	struct event ev_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
ev_realloc	ev.c	/^ev_realloc (void *ptr, long size)$/;"	f	signature:(void *ptr, long size)
ev_ref	ev.c	/^ev_ref (EV_P) EV_THROW$/;"	f
ev_res	event.h	/^  int ev_res;$/;"	m	struct:event	access:public
ev_resume	ev.c	/^ev_resume (EV_P) EV_THROW$/;"	f
ev_rt_now	ev.c	/^    ev_tstamp ev_rt_now;$/;"	m	struct:ev_loop	file:	access:public
ev_rt_now	ev.c	/^  EV_API_DECL ev_tstamp ev_rt_now = 0; \/* needs to be initialised to make it a definition despite extern *\/$/;"	v
ev_rt_now	ev.c	1617;"	d	file:
ev_rt_now	ev.h	/^EV_API_DECL ev_tstamp ev_rt_now;$/;"	v
ev_run	ev.c	/^ev_run (EV_P_ int flags)$/;"	f	signature:(EV_P_ int flags)
ev_run	ev.h	/^EV_API_DECL int  ev_run (EV_P_ int flags EV_CPP (= 0));$/;"	p	signature:(EV_P_ int flags EV_CPP (= 0))
ev_set_cb	ev.h	735;"	d
ev_set_priority	ev.h	726;"	d
ev_set_priority	ev.h	729;"	d
ev_sighandler	ev.c	/^ev_sighandler (int signum)$/;"	f	file:	signature:(int signum)
ev_signal	ev.h	/^typedef struct ev_signal$/;"	s
ev_signal	ev.h	/^} ev_signal;$/;"	t	typeref:struct:ev_signal
ev_signal::signum	ev.h	/^  int signum; \/* ro *\/$/;"	m	struct:ev_signal	access:public
ev_signal_init	ev.h	708;"	d
ev_signal_set	ev.h	694;"	d
ev_start	ev.c	/^ev_start (EV_P_ W w, int active)$/;"	f	signature:(EV_P_ W w, int active)
ev_stat	ev.h	/^typedef struct ev_stat$/;"	s
ev_stat	ev.h	/^} ev_stat;$/;"	t	typeref:struct:ev_stat
ev_stat::attr	ev.h	/^  ev_statdata attr;   \/* ro *\/$/;"	m	struct:ev_stat	access:public
ev_stat::interval	ev.h	/^  ev_tstamp interval; \/* ro *\/$/;"	m	struct:ev_stat	access:public
ev_stat::path	ev.h	/^  const char *path;   \/* ro *\/$/;"	m	struct:ev_stat	access:public
ev_stat::prev	ev.h	/^  ev_statdata prev;   \/* ro *\/$/;"	m	struct:ev_stat	access:public
ev_stat::timer	ev.h	/^  ev_timer timer;     \/* private *\/$/;"	m	struct:ev_stat	access:public
ev_stat::wd	ev.h	/^  int wd; \/* wd for inotify, fd for kqueue *\/$/;"	m	struct:ev_stat	access:public
ev_stat_init	ev.h	710;"	d
ev_stat_set	ev.h	696;"	d
ev_statdata	ev.h	/^typedef struct _stati64 ev_statdata;$/;"	t	typeref:struct:_stati64
ev_statdata	ev.h	/^typedef struct stat ev_statdata;$/;"	t	typeref:struct:stat
ev_stop	ev.c	/^ev_stop (EV_P_ W w)$/;"	f	signature:(EV_P_ W w)
ev_suspend	ev.c	/^ev_suspend (EV_P) EV_THROW$/;"	f
ev_syserr	ev.c	/^ev_syserr (const char *msg)$/;"	f	file:	signature:(const char *msg)
ev_tcp_socket	ev_win32.c	/^ev_tcp_socket (void)$/;"	f	file:	signature:(void)
ev_time	ev_win32.c	/^ev_time (void)$/;"	f	signature:(void)
ev_timer	ev.h	/^typedef struct ev_timer$/;"	s
ev_timer	ev.h	/^} ev_timer;$/;"	t	typeref:struct:ev_timer
ev_timer::repeat	ev.h	/^  ev_tstamp repeat; \/* rw *\/$/;"	m	struct:ev_timer	access:public
ev_timer_init	ev.h	706;"	d
ev_timer_set	ev.h	692;"	d
ev_tstamp	ev.h	/^typedef double ev_tstamp;$/;"	t
ev_tv_get	event.c	/^ev_tv_get (struct timeval *tv)$/;"	f	file:	signature:(struct timeval *tv)
ev_unloop	ev.h	/^    EV_INLINE void ev_unloop (EV_P_ int how  ) { ev_break (EV_A_ how  ); }$/;"	f	signature:(EV_P_ int how )
ev_unref	ev.c	/^ev_unref (EV_P) EV_THROW$/;"	f
ev_userdata	ev.c	/^ev_userdata (EV_P) EV_THROW$/;"	f
ev_verify	ev.c	/^ev_verify (EV_P) EV_THROW$/;"	f
ev_watcher	ev.h	/^typedef struct ev_watcher$/;"	s
ev_watcher	ev.h	/^} ev_watcher;$/;"	t	typeref:struct:ev_watcher
ev_watcher_list	ev.h	/^typedef struct ev_watcher_list$/;"	s
ev_watcher_list	ev.h	/^} ev_watcher_list;$/;"	t	typeref:struct:ev_watcher_list
ev_watcher_time	ev.h	/^typedef struct ev_watcher_time$/;"	s
ev_watcher_time	ev.h	/^} ev_watcher_time;$/;"	t	typeref:struct:ev_watcher_time
ev_write	event_compat.h	/^	struct event ev_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
ev_x_cb	event.c	/^ev_x_cb (struct event *ev, int revents)$/;"	f	file:	signature:(struct event *ev, int revents)
ev_x_cb_io	event.c	/^ev_x_cb_io (EV_P_ struct ev_io *w, int revents)$/;"	f	file:	signature:(EV_P_ struct ev_io *w, int revents)
ev_x_cb_sig	event.c	/^ev_x_cb_sig (EV_P_ struct ev_signal *w, int revents)$/;"	f	file:	signature:(EV_P_ struct ev_signal *w, int revents)
ev_x_cb_to	event.c	/^ev_x_cb_to (EV_P_ struct ev_timer *w, int revents)$/;"	f	file:	signature:(EV_P_ struct ev_timer *w, int revents)
ev_x_cur	event.c	/^static struct event_base *ev_x_cur;$/;"	v	typeref:struct:event_base	file:
ev_x_loopexit_cb	event.c	/^ev_x_loopexit_cb (int revents, void *base)$/;"	f	file:	signature:(int revents, void *base)
ev_x_once	event.c	/^struct ev_x_once$/;"	s	file:
ev_x_once::arg	event.c	/^  void *arg;$/;"	m	struct:ev_x_once	file:	access:public
ev_x_once::cb	event.c	/^  void (*cb)(int, short, void *);$/;"	m	struct:ev_x_once	file:	access:public
ev_x_once::fd	event.c	/^  int fd;$/;"	m	struct:ev_x_once	file:	access:public
ev_x_once_cb	event.c	/^ev_x_once_cb (int revents, void *arg)$/;"	f	file:	signature:(int revents, void *arg)
evbuffer	event_compat.h	/^struct evbuffer {$/;"	s
evbuffer::buffer	event_compat.h	/^	u_char *buffer;$/;"	m	struct:evbuffer	access:public
evbuffer::cb	event_compat.h	/^	void (*cb)(struct evbuffer *, size_t, size_t, void *);$/;"	m	struct:evbuffer	access:public
evbuffer::cbarg	event_compat.h	/^	void *cbarg;$/;"	m	struct:evbuffer	access:public
evbuffer::misalign	event_compat.h	/^	size_t misalign;$/;"	m	struct:evbuffer	access:public
evbuffer::off	event_compat.h	/^	size_t off;$/;"	m	struct:evbuffer	access:public
evbuffer::orig_buffer	event_compat.h	/^	u_char *orig_buffer;$/;"	m	struct:evbuffer	access:public
evbuffer::totallen	event_compat.h	/^	size_t totallen;$/;"	m	struct:evbuffer	access:public
evbuffer_add	event_compat.h	/^int evbuffer_add(struct evbuffer *, const void *, size_t);$/;"	p	signature:(struct evbuffer *, const void *, size_t)
evbuffer_add_buffer	event_compat.h	/^int evbuffer_add_buffer(struct evbuffer *, struct evbuffer *);$/;"	p	signature:(struct evbuffer *, struct evbuffer *)
evbuffer_add_printf	event_compat.h	/^int evbuffer_add_printf(struct evbuffer *, const char *fmt, ...);$/;"	p	signature:(struct evbuffer *, const char *fmt, ...)
evbuffer_add_vprintf	event_compat.h	/^int evbuffer_add_vprintf(struct evbuffer *, const char *fmt, va_list ap);$/;"	p	signature:(struct evbuffer *, const char *fmt, va_list ap)
evbuffer_drain	event_compat.h	/^void evbuffer_drain(struct evbuffer *, size_t);$/;"	p	signature:(struct evbuffer *, size_t)
evbuffer_expand	event_compat.h	/^int evbuffer_expand(struct evbuffer *, size_t);$/;"	p	signature:(struct evbuffer *, size_t)
evbuffer_find	event_compat.h	/^u_char *evbuffer_find(struct evbuffer *, const u_char *, size_t);$/;"	p	signature:(struct evbuffer *, const u_char *, size_t)
evbuffer_free	event_compat.h	/^void evbuffer_free(struct evbuffer *);$/;"	p	signature:(struct evbuffer *)
evbuffer_new	event_compat.h	/^struct evbuffer *evbuffer_new(void);$/;"	p	signature:(void)
evbuffer_read	event_compat.h	/^int evbuffer_read(struct evbuffer *, int, int);$/;"	p	signature:(struct evbuffer *, int, int)
evbuffer_readline	event_compat.h	/^char *evbuffer_readline(struct evbuffer *);$/;"	p	signature:(struct evbuffer *)
evbuffer_remove	event_compat.h	/^int evbuffer_remove(struct evbuffer *, void *, size_t);$/;"	p	signature:(struct evbuffer *, void *, size_t)
evbuffer_setcb	event_compat.h	/^void evbuffer_setcb(struct evbuffer *, void (*)(struct evbuffer *, size_t, size_t, void *), void *);$/;"	p	signature:(struct evbuffer *, void (*)(struct evbuffer *, size_t, size_t, void *), void *)
evbuffer_write	event_compat.h	/^int evbuffer_write(struct evbuffer *, int);$/;"	p	signature:(struct evbuffer *, int)
evbuffercb	event_compat.h	/^typedef void (*evbuffercb)(struct bufferevent *, void *);$/;"	t
event	event.h	/^struct event$/;"	s
event::__anon4::io	event.h	/^    struct ev_io io;$/;"	m	union:event::__anon4	typeref:struct:event::__anon4::ev_io	access:public
event::__anon4::sig	event.h	/^    struct ev_signal sig;$/;"	m	union:event::__anon4	typeref:struct:event::__anon4::ev_signal	access:public
event::ev_arg	event.h	/^  void *ev_arg;$/;"	m	struct:event	access:public
event::ev_base	event.h	/^  struct event_base *ev_base;$/;"	m	struct:event	typeref:struct:event::event_base	access:public
event::ev_callback	event.h	/^  event_callback_fn ev_callback;$/;"	m	struct:event	access:public
event::ev_events	event.h	/^  short ev_events;$/;"	m	struct:event	access:public
event::ev_fd	event.h	/^  int ev_fd;$/;"	m	struct:event	access:public
event::ev_flags	event.h	/^  int ev_flags;$/;"	m	struct:event	access:public
event::ev_pri	event.h	/^  int ev_pri;$/;"	m	struct:event	access:public
event::ev_res	event.h	/^  int ev_res;$/;"	m	struct:event	access:public
event::iosig	event.h	/^  } iosig;$/;"	m	struct:event	typeref:union:event::__anon4	access:public
event::to	event.h	/^  struct ev_timer to;$/;"	m	struct:event	typeref:struct:event::ev_timer	access:public
event_active	event.c	/^void event_active (struct event *ev, int res, short ncalls)$/;"	f	signature:(struct event *ev, int res, short ncalls)
event_active	event.h	/^void event_active (struct event *ev, int res, short ncalls); \/* ncalls is being ignored *\/$/;"	p	signature:(struct event *ev, int res, short ncalls)
event_add	event.c	/^int event_add (struct event *ev, struct timeval *tv)$/;"	f	signature:(struct event *ev, struct timeval *tv)
event_add	event.h	/^int event_add (struct event *ev, struct timeval *tv);$/;"	p	signature:(struct event *ev, struct timeval *tv)
event_base	event.c	/^struct event_base$/;"	s	file:
event_base::dummy	event.c	/^  int dummy;$/;"	m	struct:event_base	file:	access:public
event_base_dispatch	event.c	/^int event_base_dispatch (struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_dispatch	event.h	/^int event_base_dispatch (struct event_base *base);$/;"	p	signature:(struct event_base *base)
event_base_free	event.c	/^void event_base_free (struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_free	event.h	/^void event_base_free (struct event_base *base);$/;"	p	signature:(struct event_base *base)
event_base_get_method	event.c	/^event_base_get_method (const struct event_base *base)$/;"	f	signature:(const struct event_base *base)
event_base_get_method	event.h	/^const char *event_base_get_method (const struct event_base *);$/;"	p	signature:(const struct event_base *)
event_base_loop	event.c	/^int event_base_loop (struct event_base *base, int flags)$/;"	f	signature:(struct event_base *base, int flags)
event_base_loop	event.h	/^int event_base_loop (struct event_base *base, int);$/;"	p	signature:(struct event_base *base, int)
event_base_loopexit	event.c	/^int event_base_loopexit (struct event_base *base, struct timeval *tv)$/;"	f	signature:(struct event_base *base, struct timeval *tv)
event_base_loopexit	event.h	/^int event_base_loopexit (struct event_base *base, struct timeval *tv);$/;"	p	signature:(struct event_base *base, struct timeval *tv)
event_base_new	event.c	/^event_base_new (void)$/;"	f	signature:(void)
event_base_new	event.h	/^struct event_base *event_base_new (void);$/;"	p	signature:(void)
event_base_once	event.c	/^int event_base_once (struct event_base *base, int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv)$/;"	f	signature:(struct event_base *base, int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv)
event_base_once	event.h	/^int event_base_once (struct event_base *base, int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv);$/;"	p	signature:(struct event_base *base, int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv)
event_base_priority_init	event.c	/^int event_base_priority_init (struct event_base *base, int npri)$/;"	f	signature:(struct event_base *base, int npri)
event_base_priority_init	event.h	/^int event_base_priority_init (struct event_base *base, int fd);$/;"	p	signature:(struct event_base *base, int fd)
event_base_set	event.c	/^int event_base_set (struct event_base *base, struct event *ev)$/;"	f	signature:(struct event_base *base, struct event *ev)
event_base_set	event.h	/^int event_base_set (struct event_base *base, struct event *ev);$/;"	p	signature:(struct event_base *base, struct event *ev)
event_callback_fn	event.h	/^typedef void (*event_callback_fn)(int, short, void *);$/;"	t
event_del	event.c	/^int event_del (struct event *ev)$/;"	f	signature:(struct event *ev)
event_del	event.h	/^int event_del (struct event *ev);$/;"	p	signature:(struct event *ev)
event_dispatch	event.c	/^int event_dispatch (void)$/;"	f	signature:(void)
event_dispatch	event.h	/^int event_dispatch (void);$/;"	p	signature:(void)
event_get_callback	event.c	/^event_callback_fn event_get_callback$/;"	f	signature:(const struct event *ev)
event_get_callback	event.h	/^event_callback_fn event_get_callback (const struct event *ev);$/;"	p	signature:(const struct event *ev)
event_get_method	event.c	/^event_get_method (void)$/;"	f	signature:(void)
event_get_method	event.h	/^const char *event_get_method (void);$/;"	p	signature:(void)
event_get_version	event.c	/^event_get_version (void)$/;"	f	signature:(void)
event_get_version	event.h	/^const char *event_get_version (void);$/;"	p	signature:(void)
event_init	event.c	/^void *event_init (void)$/;"	f	signature:(void)
event_init	event.h	/^void *event_init (void);$/;"	p	signature:(void)
event_initialized	event.h	110;"	d
event_log_cb	event.h	/^typedef void (*event_log_cb)(int severity, const char *msg);$/;"	t
event_loop	event.c	/^int event_loop (int flags)$/;"	f	signature:(int flags)
event_loop	event.h	/^int event_loop (int);$/;"	p	signature:(int)
event_loopexit	event.c	/^int event_loopexit (struct timeval *tv)$/;"	f	signature:(struct timeval *tv)
event_loopexit	event.h	/^int event_loopexit (struct timeval *tv);$/;"	p	signature:(struct timeval *tv)
event_once	event.c	/^int event_once (int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv)$/;"	f	signature:(int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv)
event_once	event.h	/^int event_once (int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv);$/;"	p	signature:(int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv)
event_pending	event.c	/^int event_pending (struct event *ev, short events, struct timeval *tv)$/;"	f	signature:(struct event *ev, short events, struct timeval *tv)
event_pending	event.h	/^int event_pending (struct event *ev, short, struct timeval *tv);$/;"	p	signature:(struct event *ev, short, struct timeval *tv)
event_priority_init	event.c	/^int event_priority_init (int npri)$/;"	f	signature:(int npri)
event_priority_init	event.h	/^int event_priority_init (int npri);$/;"	p	signature:(int npri)
event_priority_set	event.c	/^int event_priority_set (struct event *ev, int pri)$/;"	f	signature:(struct event *ev, int pri)
event_priority_set	event.h	/^int event_priority_set (struct event *ev, int pri);$/;"	p	signature:(struct event *ev, int pri)
event_set	event.c	/^void event_set (struct event *ev, int fd, short events, void (*cb)(int, short, void *), void *arg)$/;"	f	signature:(struct event *ev, int fd, short events, void (*cb)(int, short, void *), void *arg)
event_set	event.h	/^void event_set (struct event *ev, int fd, short events, void (*cb)(int, short, void *), void *arg);$/;"	p	signature:(struct event *ev, int fd, short events, void (*cb)(int, short, void *), void *arg)
event_set_log_callback	event.c	/^void event_set_log_callback (event_log_cb cb)$/;"	f	signature:(event_log_cb cb)
event_set_log_callback	event.h	/^void event_set_log_callback(event_log_cb cb);$/;"	p	signature:(event_log_cb cb)
event_watermark	event_compat.h	/^struct event_watermark {$/;"	s
event_watermark::high	event_compat.h	/^	size_t high;$/;"	m	struct:event_watermark	access:public
event_watermark::low	event_compat.h	/^	size_t low;$/;"	m	struct:event_watermark	access:public
eventfd	ev.c	/^EV_CPP(extern "C") int (eventfd) (unsigned int initval, int flags);$/;"	p	file:	signature:(unsigned int initval, int flags)
eventop	event_compat.h	/^struct eventop {$/;"	s
eventop::add	event_compat.h	/^	int (*add)(void *, struct event *);$/;"	m	struct:eventop	access:public
eventop::dealloc	event_compat.h	/^	void (*dealloc)(struct event_base *, void *);$/;"	m	struct:eventop	access:public
eventop::del	event_compat.h	/^	int (*del)(void *, struct event *);$/;"	m	struct:eventop	access:public
eventop::dispatch	event_compat.h	/^	int (*dispatch)(struct event_base *, void *, struct timeval *);$/;"	m	struct:eventop	access:public
eventop::init	event_compat.h	/^	void *(*init)(struct event_base *);$/;"	m	struct:eventop	access:public
eventop::name	event_compat.h	/^	char *name;$/;"	m	struct:eventop	access:public
eventop::recalc	event_compat.h	/^	int (*recalc)(struct event_base *, void *, int);$/;"	m	struct:eventop	access:public
events	ev.c	/^  int events; \/* the pending event set for the given watcher *\/$/;"	m	struct:__anon6	file:	access:public
events	ev.c	/^  unsigned char events; \/* the events watched for *\/$/;"	m	struct:__anon5	file:	access:public
events	ev.h	/^  int events; \/* ro *\/$/;"	m	struct:ev_io	access:public
everrorcb	event_compat.h	/^typedef void (*everrorcb)(struct bufferevent *, short what, void *);$/;"	t
evkeyval	event_compat.h	/^struct evkeyval {$/;"	s
evkeyval::key	event_compat.h	/^	char *key;$/;"	m	struct:evkeyval	access:public
evkeyval::next	event_compat.h	/^	TAILQ_ENTRY(evkeyval) next;$/;"	m	struct:evkeyval	access:public
evkeyval::value	event_compat.h	/^	char *value;$/;"	m	struct:evkeyval	access:public
evpipe	ev_wrap.h	128;"	d
evpipe	ev_wrap.h	29;"	d
evpipe_init	ev.c	/^evpipe_init (EV_P)$/;"	f	file:
evpipe_write	ev.c	/^evpipe_write (EV_P_ EV_ATOMIC_T *flag)$/;"	f	signature:(EV_P_ EV_ATOMIC_T *flag)
evtag_consume	event_compat.h	/^int evtag_consume(struct evbuffer *evbuf);$/;"	p	signature:(struct evbuffer *evbuf)
evtag_init	event_compat.h	/^void evtag_init(void);$/;"	p	signature:(void)
evtag_marshal	event_compat.h	/^void evtag_marshal(struct evbuffer *evbuf, uint32_t tag, const void *data,$/;"	p	signature:(struct evbuffer *evbuf, uint32_t tag, const void *data, uint32_t len)
evtag_marshal_int	event_compat.h	/^void evtag_marshal_int(struct evbuffer *evbuf, uint32_t tag, uint32_t integer);$/;"	p	signature:(struct evbuffer *evbuf, uint32_t tag, uint32_t integer)
evtag_marshal_string	event_compat.h	/^void evtag_marshal_string(struct evbuffer *buf, uint32_t tag,$/;"	p	signature:(struct evbuffer *buf, uint32_t tag, const char *string)
evtag_marshal_timeval	event_compat.h	/^void evtag_marshal_timeval(struct evbuffer *evbuf, uint32_t tag,$/;"	p	signature:(struct evbuffer *evbuf, uint32_t tag, struct timeval *tv)
evtag_payload_length	event_compat.h	/^int evtag_payload_length(struct evbuffer *evbuf, uint32_t *plength);$/;"	p	signature:(struct evbuffer *evbuf, uint32_t *plength)
evtag_peek	event_compat.h	/^int evtag_peek(struct evbuffer *evbuf, uint32_t *ptag);$/;"	p	signature:(struct evbuffer *evbuf, uint32_t *ptag)
evtag_peek_length	event_compat.h	/^int evtag_peek_length(struct evbuffer *evbuf, uint32_t *plength);$/;"	p	signature:(struct evbuffer *evbuf, uint32_t *plength)
evtag_unmarshal	event_compat.h	/^int evtag_unmarshal(struct evbuffer *src, uint32_t *ptag, struct evbuffer *dst);$/;"	p	signature:(struct evbuffer *src, uint32_t *ptag, struct evbuffer *dst)
evtag_unmarshal_fixed	event_compat.h	/^int evtag_unmarshal_fixed(struct evbuffer *src, uint32_t need_tag, void *data,$/;"	p	signature:(struct evbuffer *src, uint32_t need_tag, void *data, size_t len)
evtag_unmarshal_int	event_compat.h	/^int evtag_unmarshal_int(struct evbuffer *evbuf, uint32_t need_tag,$/;"	p	signature:(struct evbuffer *evbuf, uint32_t need_tag, uint32_t *pinteger)
evtag_unmarshal_string	event_compat.h	/^int evtag_unmarshal_string(struct evbuffer *evbuf, uint32_t need_tag,$/;"	p	signature:(struct evbuffer *evbuf, uint32_t need_tag, char **pstring)
evtag_unmarshal_timeval	event_compat.h	/^int evtag_unmarshal_timeval(struct evbuffer *evbuf, uint32_t need_tag,$/;"	p	signature:(struct evbuffer *evbuf, uint32_t need_tag, struct timeval *ptv)
evtimer_add	event.h	112;"	d
evtimer_del	event.h	114;"	d
evtimer_initialized	event.h	116;"	d
evtimer_pending	event.h	115;"	d
evtimer_set	event.h	113;"	d
exec_prefix	Makefile	/^exec_prefix = ${prefix}$/;"	m
expect_false	ev.c	1323;"	d	file:
expect_true	ev.c	1324;"	d	file:
fd	ev.h	/^  int fd;     \/* ro *\/$/;"	m	struct:ev_io	access:public
fd	event.c	/^  int fd;$/;"	m	struct:ev_x_once	file:	access:public
fd_change	ev.c	/^fd_change (EV_P_ int fd, int flags)$/;"	f	signature:(EV_P_ int fd, int flags)
fd_ebadf	ev.c	/^fd_ebadf (EV_P)$/;"	f	file:
fd_enomem	ev.c	/^fd_enomem (EV_P)$/;"	f	file:
fd_event	ev.c	/^fd_event (EV_P_ int fd, int revents)$/;"	f	signature:(EV_P_ int fd, int revents)
fd_event_nocheck	ev.c	/^fd_event_nocheck (EV_P_ int fd, int revents)$/;"	f	signature:(EV_P_ int fd, int revents)
fd_intern	ev.c	/^fd_intern (int fd)$/;"	f	signature:(int fd)
fd_kill	ev.c	/^fd_kill (EV_P_ int fd)$/;"	f	signature:(EV_P_ int fd)
fd_rearm_all	ev.c	/^fd_rearm_all (EV_P)$/;"	f	file:
fd_reify	ev.c	/^fd_reify (EV_P)$/;"	f
fd_valid	ev.c	/^fd_valid (int fd)$/;"	f	signature:(int fd)
fdchangecnt	ev_wrap.h	129;"	d
fdchangecnt	ev_wrap.h	30;"	d
fdchangemax	ev_wrap.h	130;"	d
fdchangemax	ev_wrap.h	31;"	d
fdchanges	ev_wrap.h	131;"	d
fdchanges	ev_wrap.h	32;"	d
feed_event	ev++.h	/^    void feed_event (int revents) throw ()$/;"	f	struct:ev::base	access:public	signature:(int revents)
feed_fd_event	ev++.h	/^    void feed_fd_event (int fd, int revents) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(int fd, int revents)
feed_reverse	ev.c	/^feed_reverse (EV_P_ W w)$/;"	f	signature:(EV_P_ W w)
feed_reverse_done	ev.c	/^feed_reverse_done (EV_P_ int revents)$/;"	f	signature:(EV_P_ int revents)
feed_signal_event	ev++.h	/^    void feed_signal_event (int signum) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(int signum)
flags	ev.h	/^  int flags;   \/* private *\/$/;"	m	struct:ev_child	access:public
fork	ev.h	/^  ev_fork fork;          \/* private *\/$/;"	m	struct:ev_embed	access:public
fork	ev.h	/^  struct ev_fork fork;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_fork	access:public
forkcnt	ev_wrap.h	132;"	d
forkcnt	ev_wrap.h	33;"	d
forkmax	ev_wrap.h	133;"	d
forkmax	ev_wrap.h	34;"	d
forks	ev_wrap.h	134;"	d
forks	ev_wrap.h	35;"	d
fs_2625	ev_wrap.h	135;"	d
fs_2625	ev_wrap.h	36;"	d
fs_fd	ev_wrap.h	136;"	d
fs_fd	ev_wrap.h	37;"	d
fs_hash	ev_wrap.h	137;"	d
fs_hash	ev_wrap.h	38;"	d
fs_w	ev_wrap.h	138;"	d
fs_w	ev_wrap.h	39;"	d
func_append	config.status	/^func_append ()$/;"	f
func_append	configure	/^func_append ()$/;"	f
func_append	libtool	/^func_append ()$/;"	f
func_arith	config.status	/^func_arith ()$/;"	f
func_arith	configure	/^func_arith ()$/;"	f
func_arith	libtool	/^func_arith ()$/;"	f
func_basename	config.status	/^func_basename ()$/;"	f
func_basename	configure	/^func_basename ()$/;"	f
func_basename	libtool	/^func_basename ()$/;"	f
func_check_version_match	libtool	/^func_check_version_match ()$/;"	f
func_check_version_match	ltmain.sh	/^func_check_version_match ()$/;"	f
func_config	libtool	/^func_config ()$/;"	f
func_config	ltmain.sh	/^func_config ()$/;"	f
func_dirname	config.status	/^func_dirname ()$/;"	f
func_dirname	configure	/^func_dirname ()$/;"	f
func_dirname	libtool	/^func_dirname ()$/;"	f
func_dirname_and_basename	config.status	/^func_dirname_and_basename ()$/;"	f
func_dirname_and_basename	configure	/^func_dirname_and_basename ()$/;"	f
func_dirname_and_basename	libtool	/^func_dirname_and_basename ()$/;"	f
func_dirname_and_basename	ltmain.sh	/^func_dirname_and_basename ()$/;"	f
func_echo	libtool	/^func_echo ()$/;"	f
func_echo	ltmain.sh	/^func_echo ()$/;"	f
func_emit_cwrapperexe_src	libtool	/^func_emit_cwrapperexe_src ()$/;"	f
func_emit_cwrapperexe_src	ltmain.sh	/^func_emit_cwrapperexe_src ()$/;"	f
func_emit_wrapper	libtool	/^func_emit_wrapper ()$/;"	f
func_emit_wrapper	ltmain.sh	/^func_emit_wrapper ()$/;"	f
func_emit_wrapper_part1	libtool	/^func_emit_wrapper_part1 ()$/;"	f
func_emit_wrapper_part1	ltmain.sh	/^func_emit_wrapper_part1 ()$/;"	f
func_emit_wrapper_part2	libtool	/^func_emit_wrapper_part2 ()$/;"	f
func_emit_wrapper_part2	ltmain.sh	/^func_emit_wrapper_part2 ()$/;"	f
func_enable_tag	libtool	/^func_enable_tag ()$/;"	f
func_enable_tag	ltmain.sh	/^func_enable_tag ()$/;"	f
func_error	libtool	/^func_error ()$/;"	f
func_error	ltmain.sh	/^func_error ()$/;"	f
func_execute_cmds	libtool	/^func_execute_cmds ()$/;"	f
func_execute_cmds	ltmain.sh	/^func_execute_cmds ()$/;"	f
func_extract_an_archive	libtool	/^func_extract_an_archive ()$/;"	f
func_extract_an_archive	ltmain.sh	/^func_extract_an_archive ()$/;"	f
func_extract_archives	libtool	/^func_extract_archives ()$/;"	f
func_extract_archives	ltmain.sh	/^func_extract_archives ()$/;"	f
func_fatal_configuration	libtool	/^func_fatal_configuration ()$/;"	f
func_fatal_configuration	ltmain.sh	/^func_fatal_configuration ()$/;"	f
func_fatal_error	libtool	/^func_fatal_error ()$/;"	f
func_fatal_error	ltmain.sh	/^func_fatal_error ()$/;"	f
func_fatal_help	libtool	/^func_fatal_help ()$/;"	f
func_fatal_help	ltmain.sh	/^func_fatal_help ()$/;"	f
func_features	libtool	/^func_features ()$/;"	f
func_features	ltmain.sh	/^func_features ()$/;"	f
func_generate_dlsyms	libtool	/^func_generate_dlsyms ()$/;"	f
func_generate_dlsyms	ltmain.sh	/^func_generate_dlsyms ()$/;"	f
func_grep	libtool	/^func_grep ()$/;"	f
func_grep	ltmain.sh	/^func_grep ()$/;"	f
func_help	libtool	/^func_help ()$/;"	f
func_help	ltmain.sh	/^func_help ()$/;"	f
func_infer_tag	libtool	/^func_infer_tag ()$/;"	f
func_infer_tag	ltmain.sh	/^func_infer_tag ()$/;"	f
func_lalib_p	libtool	/^func_lalib_p ()$/;"	f
func_lalib_p	ltmain.sh	/^func_lalib_p ()$/;"	f
func_lalib_unsafe_p	libtool	/^func_lalib_unsafe_p ()$/;"	f
func_lalib_unsafe_p	ltmain.sh	/^func_lalib_unsafe_p ()$/;"	f
func_len	config.status	/^func_len ()$/;"	f
func_len	configure	/^func_len ()$/;"	f
func_len	libtool	/^func_len ()$/;"	f
func_lo2o	config.status	/^func_lo2o ()$/;"	f
func_lo2o	configure	/^func_lo2o ()$/;"	f
func_lo2o	libtool	/^func_lo2o ()$/;"	f
func_ltwrapper_executable_p	libtool	/^func_ltwrapper_executable_p ()$/;"	f
func_ltwrapper_executable_p	ltmain.sh	/^func_ltwrapper_executable_p ()$/;"	f
func_ltwrapper_p	libtool	/^func_ltwrapper_p ()$/;"	f
func_ltwrapper_p	ltmain.sh	/^func_ltwrapper_p ()$/;"	f
func_ltwrapper_script_p	libtool	/^func_ltwrapper_script_p ()$/;"	f
func_ltwrapper_script_p	ltmain.sh	/^func_ltwrapper_script_p ()$/;"	f
func_ltwrapper_scriptname	libtool	/^func_ltwrapper_scriptname ()$/;"	f
func_ltwrapper_scriptname	ltmain.sh	/^func_ltwrapper_scriptname ()$/;"	f
func_missing_arg	libtool	/^func_missing_arg ()$/;"	f
func_missing_arg	ltmain.sh	/^func_missing_arg ()$/;"	f
func_mkdir_p	libtool	/^func_mkdir_p ()$/;"	f
func_mkdir_p	ltmain.sh	/^func_mkdir_p ()$/;"	f
func_mktempdir	libtool	/^func_mktempdir ()$/;"	f
func_mktempdir	ltmain.sh	/^func_mktempdir ()$/;"	f
func_mode_compile	libtool	/^func_mode_compile ()$/;"	f
func_mode_compile	ltmain.sh	/^func_mode_compile ()$/;"	f
func_mode_execute	libtool	/^func_mode_execute ()$/;"	f
func_mode_execute	ltmain.sh	/^func_mode_execute ()$/;"	f
func_mode_finish	libtool	/^func_mode_finish ()$/;"	f
func_mode_finish	ltmain.sh	/^func_mode_finish ()$/;"	f
func_mode_help	libtool	/^func_mode_help ()$/;"	f
func_mode_help	ltmain.sh	/^func_mode_help ()$/;"	f
func_mode_install	libtool	/^func_mode_install ()$/;"	f
func_mode_install	ltmain.sh	/^func_mode_install ()$/;"	f
func_mode_link	libtool	/^func_mode_link ()$/;"	f
func_mode_link	ltmain.sh	/^func_mode_link ()$/;"	f
func_mode_uninstall	libtool	/^func_mode_uninstall ()$/;"	f
func_mode_uninstall	ltmain.sh	/^func_mode_uninstall ()$/;"	f
func_opt_split	config.status	/^func_opt_split ()$/;"	f
func_opt_split	configure	/^func_opt_split ()$/;"	f
func_opt_split	libtool	/^func_opt_split ()$/;"	f
func_quote_for_eval	libtool	/^func_quote_for_eval ()$/;"	f
func_quote_for_eval	ltmain.sh	/^func_quote_for_eval ()$/;"	f
func_quote_for_expand	libtool	/^func_quote_for_expand ()$/;"	f
func_quote_for_expand	ltmain.sh	/^func_quote_for_expand ()$/;"	f
func_show_eval	libtool	/^func_show_eval ()$/;"	f
func_show_eval	ltmain.sh	/^func_show_eval ()$/;"	f
func_show_eval_locale	libtool	/^func_show_eval_locale ()$/;"	f
func_show_eval_locale	ltmain.sh	/^func_show_eval_locale ()$/;"	f
func_source	libtool	/^func_source ()$/;"	f
func_source	ltmain.sh	/^func_source ()$/;"	f
func_stripname	config.status	/^func_stripname ()$/;"	f
func_stripname	configure	/^func_stripname ()$/;"	f
func_stripname	libtool	/^func_stripname ()$/;"	f
func_to_host_path	libtool	/^func_to_host_path ()$/;"	f
func_to_host_path	ltmain.sh	/^func_to_host_path ()$/;"	f
func_to_host_pathlist	libtool	/^func_to_host_pathlist ()$/;"	f
func_to_host_pathlist	ltmain.sh	/^func_to_host_pathlist ()$/;"	f
func_usage	libtool	/^func_usage ()$/;"	f
func_usage	ltmain.sh	/^func_usage ()$/;"	f
func_verbose	libtool	/^func_verbose ()$/;"	f
func_verbose	ltmain.sh	/^func_verbose ()$/;"	f
func_version	libtool	/^func_version ()$/;"	f
func_version	ltmain.sh	/^func_version ()$/;"	f
func_warning	libtool	/^func_warning ()$/;"	f
func_warning	ltmain.sh	/^func_warning ()$/;"	f
func_win32_libid	libtool	/^func_win32_libid ()$/;"	f
func_win32_libid	ltmain.sh	/^func_win32_libid ()$/;"	f
func_write_libtool_object	libtool	/^func_write_libtool_object ()$/;"	f
func_write_libtool_object	ltmain.sh	/^func_write_libtool_object ()$/;"	f
func_xform	config.status	/^func_xform ()$/;"	f
func_xform	configure	/^func_xform ()$/;"	f
func_xform	libtool	/^func_xform ()$/;"	f
function_thunk	ev++.h	/^    static void function_thunk (EV_P_ ev_watcher *w, int revents)$/;"	f	struct:ev::base	access:public	signature:(EV_P_ ev_watcher *w, int revents)
get_clock	ev.c	/^get_clock (void)$/;"	f	signature:(void)
get_default_loop	ev++.h	/^  inline loop_ref get_default_loop () throw ()$/;"	f	namespace:ev	signature:()
handle	ev.c	/^  SOCKET handle;$/;"	m	struct:__anon5	file:	access:public
have_monotonic	ev.c	/^static EV_ATOMIC_T have_monotonic; \/* did clock_gettime (CLOCK_MONOTONIC) work? *\/$/;"	v	file:
have_realtime	ev.c	/^static EV_ATOMIC_T have_realtime; \/* did clock_gettime (CLOCK_REALTIME) work? *\/$/;"	v	file:
head	ev.c	/^  WL head;$/;"	m	struct:__anon5	file:	access:public
head	ev.c	/^  WL head;$/;"	m	struct:__anon7	file:	access:public
head	ev.c	/^  WL head;$/;"	m	struct:__anon9	file:	access:public
high	event_compat.h	/^	size_t high;$/;"	m	struct:event_watermark	access:public
host	Makefile	/^host = x86_64-unknown-linux-gnu$/;"	m
host_alias	Makefile	/^host_alias = $/;"	m
host_cpu	Makefile	/^host_cpu = x86_64$/;"	m
host_os	Makefile	/^host_os = linux-gnu$/;"	m
host_triplet	Makefile	/^host_triplet = x86_64-unknown-linux-gnu$/;"	m
host_vendor	Makefile	/^host_vendor = unknown$/;"	m
how_t	ev++.h	/^  enum how_t$/;"	g	namespace:ev
htmldir	Makefile	/^htmldir = ${docdir}$/;"	m
idle	ev.h	/^  ev_idle idle;          \/* unused *\/$/;"	m	struct:ev_embed	access:public
idle	ev.h	/^  struct ev_idle idle;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_idle	access:public
idle_reify	ev.c	/^idle_reify (EV_P)$/;"	f
idleall	ev_wrap.h	139;"	d
idleall	ev_wrap.h	40;"	d
idlecnt	ev_wrap.h	140;"	d
idlecnt	ev_wrap.h	41;"	d
idlemax	ev_wrap.h	141;"	d
idlemax	ev_wrap.h	42;"	d
idles	ev_wrap.h	142;"	d
idles	ev_wrap.h	43;"	d
include_HEADERS	Makefile	/^include_HEADERS = ev.h ev++.h event.h$/;"	m
includedir	Makefile	/^includedir = ${prefix}\/include$/;"	m
infodir	Makefile	/^infodir = ${datarootdir}\/info$/;"	m
infy_add	ev.c	/^infy_add (EV_P_ ev_stat *w)$/;"	f	file:	signature:(EV_P_ ev_stat *w)
infy_cb	ev.c	/^infy_cb (EV_P_ ev_io *w, int revents)$/;"	f	file:	signature:(EV_P_ ev_io *w, int revents)
infy_del	ev.c	/^infy_del (EV_P_ ev_stat *w)$/;"	f	file:	signature:(EV_P_ ev_stat *w)
infy_fork	ev.c	/^infy_fork (EV_P)$/;"	f
infy_fork	ev.c	/^inline_size void infy_fork (EV_P);$/;"	p	file:
infy_init	ev.c	/^infy_init (EV_P)$/;"	f
infy_newfd	ev.c	/^infy_newfd (void)$/;"	f	signature:(void)
infy_wd	ev.c	/^infy_wd (EV_P_ int slot, int wd, struct inotify_event *ev)$/;"	f	file:	signature:(EV_P_ int slot, int wd, struct inotify_event *ev)
init	event_compat.h	/^	void *(*init)(struct event_base *);$/;"	m	struct:eventop	access:public
inline_size	ev.c	1327;"	d	file:
inline_speed	ev.c	1330;"	d	file:
inline_speed	ev.c	1332;"	d	file:
input	event_compat.h	/^	struct evbuffer *input;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
install_sh	Makefile	/^install_sh = ${SHELL} \/home\/cheng\/company\/sdk\/client\/libev\/install-sh$/;"	m
install_sh_DATA	Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_PROGRAM	Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_SCRIPT	Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
int16_t	ev.c	/^  typedef   signed short  int16_t;$/;"	t	file:
int32_t	ev.c	/^  typedef   signed int    int32_t;$/;"	t	file:
int64_t	ev.c	/^    typedef   signed __int64   int64_t;$/;"	t	file:
int64_t	ev.c	/^    typedef   signed long long int64_t;$/;"	t	file:
int8_t	ev.c	/^  typedef   signed char   int8_t;$/;"	t	file:
interval	ev.h	/^  ev_tstamp interval; \/* ro *\/$/;"	m	struct:ev_stat	access:public
interval	ev.h	/^  ev_tstamp interval; \/* rw *\/$/;"	m	struct:ev_periodic	access:public
intptr_t	ev.c	/^    typedef  int32_t  intptr_t;$/;"	t	file:
intptr_t	ev.c	/^    typedef  int64_t  intptr_t;$/;"	t	file:
invoke_cb	ev_wrap.h	143;"	d
invoke_cb	ev_wrap.h	44;"	d
io	ev.c	/^  ev_io io;$/;"	m	struct:ev_once	file:	access:public
io	ev.h	/^  ev_io io;              \/* private *\/$/;"	m	struct:ev_embed	access:public
io	ev.h	/^  struct ev_io io;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_io	access:public
io	event.h	/^    struct ev_io io;$/;"	m	union:event::__anon4	typeref:struct:event::__anon4::ev_io	access:public
io_blocktime	ev_wrap.h	144;"	d
io_blocktime	ev_wrap.h	45;"	d
iocp	ev_wrap.h	145;"	d
iocp	ev_wrap.h	46;"	d
iosig	event.h	/^  } iosig;$/;"	m	struct:event	typeref:union:event::__anon4	access:public
is_active	ev++.h	/^    bool is_active () const throw ()$/;"	f	struct:ev::base	access:public	signature:() const
is_default	ev++.h	/^    bool is_default () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
is_pending	ev++.h	/^    bool is_pending () const throw ()$/;"	f	struct:ev::base	access:public	signature:() const
iteration	ev++.h	/^    unsigned int iteration () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
key	event_compat.h	/^	char *key;$/;"	m	struct:evkeyval	access:public
kqueue_change	ev_kqueue.c	/^kqueue_change (EV_P_ int fd, int filter, int flags, int fflags)$/;"	f	signature:(EV_P_ int fd, int filter, int flags, int fflags)
kqueue_changecnt	ev_wrap.h	146;"	d
kqueue_changecnt	ev_wrap.h	47;"	d
kqueue_changemax	ev_wrap.h	147;"	d
kqueue_changemax	ev_wrap.h	48;"	d
kqueue_changes	ev_wrap.h	148;"	d
kqueue_changes	ev_wrap.h	49;"	d
kqueue_destroy	ev_kqueue.c	/^kqueue_destroy (EV_P)$/;"	f
kqueue_eventmax	ev_wrap.h	149;"	d
kqueue_eventmax	ev_wrap.h	50;"	d
kqueue_events	ev_wrap.h	150;"	d
kqueue_events	ev_wrap.h	51;"	d
kqueue_fd_pid	ev_wrap.h	151;"	d
kqueue_fd_pid	ev_wrap.h	52;"	d
kqueue_fork	ev_kqueue.c	/^kqueue_fork (EV_P)$/;"	f
kqueue_init	ev_kqueue.c	/^kqueue_init (EV_P_ int flags)$/;"	f	signature:(EV_P_ int flags)
kqueue_modify	ev_kqueue.c	/^kqueue_modify (EV_P_ int fd, int oev, int nev)$/;"	f	file:	signature:(EV_P_ int fd, int oev, int nev)
kqueue_poll	ev_kqueue.c	/^kqueue_poll (EV_P_ ev_tstamp timeout)$/;"	f	file:	signature:(EV_P_ ev_tstamp timeout)
lib_LTLIBRARIES	Makefile	/^lib_LTLIBRARIES = libev.la$/;"	m
libdir	Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libev_la_LDFLAGS	Makefile	/^libev_la_LDFLAGS = -version-info $(VERSION_INFO)$/;"	m
libev_la_LIBADD	Makefile	/^libev_la_LIBADD =$/;"	m
libev_la_LINK	Makefile	/^libev_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
libev_la_OBJECTS	Makefile	/^libev_la_OBJECTS = $(am_libev_la_OBJECTS)$/;"	m
libev_la_SOURCES	Makefile	/^libev_la_SOURCES = ev.c event.c$/;"	m
libexecdir	Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
localedir	Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localstatedir	Makefile	/^localstatedir = ${prefix}\/var$/;"	m
loop	ev++.h	/^    void loop (int flags = 0)$/;"	f	struct:ev::loop_ref	access:public	signature:(int flags = 0)
loop_count	ev_wrap.h	152;"	d
loop_count	ev_wrap.h	53;"	d
loop_depth	ev_wrap.h	153;"	d
loop_depth	ev_wrap.h	54;"	d
loop_done	ev_wrap.h	154;"	d
loop_done	ev_wrap.h	55;"	d
loop_fork	ev.c	/^loop_fork (EV_P)$/;"	f
loop_ref	ev++.h	/^    loop_ref (EV_P) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(EV_P)
loop_ref	ev++.h	/^  struct loop_ref$/;"	s	namespace:ev
low	event_compat.h	/^	size_t low;$/;"	m	struct:event_watermark	access:public
lstat	ev.c	3994;"	d	file:
lstat	ev.c	3995;"	d	file:
lt_ECHO	Makefile	/^lt_ECHO = echo$/;"	m
main	config.guess	/^		main()$/;"	f
main	config.guess	/^	main ()$/;"	f
main	config.guess	/^main ()$/;"	f
man3dir	Makefile	/^man3dir = $(mandir)\/man3$/;"	m
man_MANS	Makefile	/^man_MANS = ev.3$/;"	m
mandir	Makefile	/^mandir = ${datarootdir}\/man$/;"	m
method_noargs_thunk	ev++.h	/^    static void method_noargs_thunk (EV_P_ ev_watcher *w, int revents)$/;"	f	struct:ev::base	access:public	signature:(EV_P_ ev_watcher *w, int revents)
method_noargs_thunk	ev++.h	/^    static void method_noargs_thunk (int revents, void *arg)$/;"	f	struct:ev::loop_ref	access:public	signature:(int revents, void *arg)
method_thunk	ev++.h	/^    static void method_thunk (EV_P_ ev_watcher *w, int revents)$/;"	f	struct:ev::base	access:public	signature:(EV_P_ ev_watcher *w, int revents)
method_thunk	ev++.h	/^    static void method_thunk (int revents, void *arg)$/;"	f	struct:ev::loop_ref	access:public	signature:(int revents, void *arg)
misalign	event_compat.h	/^	size_t misalign;$/;"	m	struct:evbuffer	access:public
mkdir_p	Makefile	/^mkdir_p = \/bin\/mkdir -p$/;"	m
mkinstalldirs	Makefile	/^mkinstalldirs = $(install_sh) -d$/;"	m
mn_now	ev_wrap.h	155;"	d
mn_now	ev_wrap.h	56;"	d
name	event_compat.h	/^	char *name;$/;"	m	struct:eventop	access:public
next	event_compat.h	/^	TAILQ_ENTRY(evkeyval) next;$/;"	m	struct:evkeyval	access:public
noinline	ev.c	1325;"	d	file:
now	ev++.h	/^    tstamp now () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
now	ev++.h	/^  inline tstamp now (EV_P) throw ()$/;"	f	namespace:ev	signature:(EV_P)
now_floor	ev_wrap.h	156;"	d
now_floor	ev_wrap.h	57;"	d
off	event_compat.h	/^	size_t off;$/;"	m	struct:evbuffer	access:public
offset	ev.h	/^  ev_tstamp offset; \/* rw *\/$/;"	m	struct:ev_periodic	access:public
oldincludedir	Makefile	/^oldincludedir = \/usr\/include$/;"	m
once	ev++.h	/^    void once (int fd, int events, tstamp timeout) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(int fd, int events, tstamp timeout)
once	ev++.h	/^    void once (int fd, int events, tstamp timeout, K *object) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(int fd, int events, tstamp timeout, K *object)
once	ev++.h	/^    void once (int fd, int events, tstamp timeout, void (*cb)(int, void *), void *arg = 0) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(int fd, int events, tstamp timeout, void (*cb)(int, void *), void *arg = 0)
once_cb	ev.c	/^once_cb (EV_P_ struct ev_once *once, int revents)$/;"	f	file:	signature:(EV_P_ struct ev_once *once, int revents)
once_cb_io	ev.c	/^once_cb_io (EV_P_ ev_io *w, int revents)$/;"	f	file:	signature:(EV_P_ ev_io *w, int revents)
once_cb_to	ev.c	/^once_cb_to (EV_P_ ev_timer *w, int revents)$/;"	f	file:	signature:(EV_P_ ev_timer *w, int revents)
operator !=	ev++.h	/^    bool operator != (const EV_P) const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(const EV_P) const
operator !=	ev++.h	/^    bool operator != (const loop_ref &other) const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(const loop_ref &other) const
operator ()	ev++.h	/^    void operator ()(int events = EV_UNDEF)$/;"	f	struct:ev::base	access:public	signature:(int events = EV_UNDEF)
operator =	ev++.h	/^    default_loop &operator = (const default_loop &);$/;"	p	struct:ev::default_loop	access:private	signature:(const default_loop &)
operator =	ev++.h	/^    dynamic_loop & operator= (const dynamic_loop &);$/;"	p	struct:ev::dynamic_loop	access:private	signature:(const dynamic_loop &)
operator ==	ev++.h	/^    bool operator == (const EV_P) const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(const EV_P) const
operator ==	ev++.h	/^    bool operator == (const loop_ref &other) const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(const loop_ref &other) const
operator const struct ev_loop *	ev++.h	/^    operator const struct ev_loop * () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
operator struct ev_loop *	ev++.h	/^    operator struct ev_loop * () const throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:() const
or	ev.c	/^  OVERLAPPED or, ow;$/;"	m	struct:__anon5	file:	access:public
orig_buffer	event_compat.h	/^	u_char *orig_buffer;$/;"	m	struct:evbuffer	access:public
origflags	ev_wrap.h	157;"	d
origflags	ev_wrap.h	58;"	d
other	ev.h	/^  struct ev_loop *other; \/* ro *\/$/;"	m	struct:ev_embed	typeref:struct:ev_embed::ev_loop	access:public
output	event_compat.h	/^	struct evbuffer *output;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
ow	ev.c	/^  OVERLAPPED or, ow;$/;"	m	struct:__anon5	file:	access:public
pad	ev.c	/^  char pad[128 - sizeof (uint32_t)];$/;"	m	struct:signalfd_siginfo	file:	access:public
path	ev.h	/^  const char *path;   \/* ro *\/$/;"	m	struct:ev_stat	access:public
pdfdir	Makefile	/^pdfdir = ${docdir}$/;"	m
pending	ev.c	/^  EV_ATOMIC_T pending;$/;"	m	struct:__anon9	file:	access:public
pending_w	ev_wrap.h	158;"	d
pending_w	ev_wrap.h	59;"	d
pendingcb	ev.c	/^pendingcb (EV_P_ ev_prepare *w, int revents)$/;"	f	file:	signature:(EV_P_ ev_prepare *w, int revents)
pendingcnt	ev_wrap.h	159;"	d
pendingcnt	ev_wrap.h	60;"	d
pendingmax	ev_wrap.h	160;"	d
pendingmax	ev_wrap.h	61;"	d
pendingpri	ev_wrap.h	161;"	d
pendingpri	ev_wrap.h	62;"	d
pendings	ev_wrap.h	162;"	d
pendings	ev_wrap.h	63;"	d
periodic	ev.h	/^  ev_periodic periodic;  \/* unused *\/$/;"	m	struct:ev_embed	access:public
periodic	ev.h	/^  struct ev_periodic periodic;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_periodic	access:public
periodic_recalc	ev.c	/^periodic_recalc (EV_P_ ev_periodic *w)$/;"	f	file:	signature:(EV_P_ ev_periodic *w)
periodiccnt	ev_wrap.h	163;"	d
periodiccnt	ev_wrap.h	64;"	d
periodicmax	ev_wrap.h	164;"	d
periodicmax	ev_wrap.h	65;"	d
periodics	ev_wrap.h	165;"	d
periodics	ev_wrap.h	66;"	d
periodics_reify	ev.c	/^periodics_reify (EV_P)$/;"	f
periodics_reschedule	ev.c	/^periodics_reschedule (EV_P)$/;"	f	file:
pid	ev.h	/^  int pid;     \/* ro *\/$/;"	m	struct:ev_child	access:public
pipe	ev_win32.c	144;"	d	file:
pipe	ev_win32.c	145;"	d	file:
pipe_w	ev_wrap.h	166;"	d
pipe_w	ev_wrap.h	67;"	d
pipe_write_skipped	ev_wrap.h	167;"	d
pipe_write_skipped	ev_wrap.h	68;"	d
pipe_write_wanted	ev_wrap.h	168;"	d
pipe_write_wanted	ev_wrap.h	69;"	d
pipecb	ev.c	/^pipecb (EV_P_ ev_io *iow, int revents)$/;"	f	file:	signature:(EV_P_ ev_io *iow, int revents)
pkgdatadir	Makefile	/^pkgdatadir = $(datadir)\/libev$/;"	m
pkgincludedir	Makefile	/^pkgincludedir = $(includedir)\/libev$/;"	m
pkglibdir	Makefile	/^pkglibdir = $(libdir)\/libev$/;"	m
pkglibexecdir	Makefile	/^pkglibexecdir = $(libexecdir)\/libev$/;"	m
poll_destroy	ev_poll.c	/^poll_destroy (EV_P)$/;"	f
poll_init	ev_poll.c	/^poll_init (EV_P_ int flags)$/;"	f	signature:(EV_P_ int flags)
poll_modify	ev_poll.c	/^poll_modify (EV_P_ int fd, int oev, int nev)$/;"	f	file:	signature:(EV_P_ int fd, int oev, int nev)
poll_poll	ev_poll.c	/^poll_poll (EV_P_ ev_tstamp timeout)$/;"	f	file:	signature:(EV_P_ ev_tstamp timeout)
pollcnt	ev_wrap.h	169;"	d
pollcnt	ev_wrap.h	70;"	d
pollidx_init	ev_poll.c	/^pollidx_init (int *base, int count)$/;"	f	signature:(int *base, int count)
pollidxmax	ev_wrap.h	170;"	d
pollidxmax	ev_wrap.h	71;"	d
pollidxs	ev_wrap.h	171;"	d
pollidxs	ev_wrap.h	72;"	d
pollmax	ev_wrap.h	172;"	d
pollmax	ev_wrap.h	73;"	d
polls	ev_wrap.h	173;"	d
polls	ev_wrap.h	74;"	d
port_associate_and_check	ev_port.c	/^port_associate_and_check (EV_P_ int fd, int ev)$/;"	f	signature:(EV_P_ int fd, int ev)
port_destroy	ev_port.c	/^port_destroy (EV_P)$/;"	f
port_eventmax	ev_wrap.h	174;"	d
port_eventmax	ev_wrap.h	75;"	d
port_events	ev_wrap.h	175;"	d
port_events	ev_wrap.h	76;"	d
port_fork	ev_port.c	/^port_fork (EV_P)$/;"	f
port_init	ev_port.c	/^port_init (EV_P_ int flags)$/;"	f	signature:(EV_P_ int flags)
port_modify	ev_port.c	/^port_modify (EV_P_ int fd, int oev, int nev)$/;"	f	file:	signature:(EV_P_ int fd, int oev, int nev)
port_poll	ev_port.c	/^port_poll (EV_P_ ev_tstamp timeout)$/;"	f	file:	signature:(EV_P_ ev_tstamp timeout)
post_fork	ev++.h	/^    void post_fork () throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:()
postfork	ev_wrap.h	176;"	d
postfork	ev_wrap.h	77;"	d
prefix	Makefile	/^prefix = \/usr\/local$/;"	m
prepare	ev.h	/^  ev_prepare prepare;    \/* private *\/$/;"	m	struct:ev_embed	access:public
prepare	ev.h	/^  struct ev_prepare prepare;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_prepare	access:public
preparecnt	ev_wrap.h	177;"	d
preparecnt	ev_wrap.h	78;"	d
preparemax	ev_wrap.h	178;"	d
preparemax	ev_wrap.h	79;"	d
prepares	ev_wrap.h	179;"	d
prepares	ev_wrap.h	80;"	d
prev	ev.h	/^  ev_statdata prev;   \/* ro *\/$/;"	m	struct:ev_stat	access:public
pri_adjust	ev.c	/^pri_adjust (EV_P_ W w)$/;"	f	signature:(EV_P_ W w)
program_transform_name	Makefile	/^program_transform_name = s,x,x,$/;"	m
prototypes	configure	/^   function prototypes and stuff, but not '\\xHH' hex character constants.$/;"	f
psdir	Makefile	/^psdir = ${docdir}$/;"	m
queue_events	ev.c	/^queue_events (EV_P_ W *events, int eventcnt, int type)$/;"	f	signature:(EV_P_ W *events, int eventcnt, int type)
readcb	event_compat.h	/^	evbuffercb readcb;$/;"	m	struct:bufferevent	access:public
recalc	event_compat.h	/^	int (*recalc)(struct event_base *, void *, int);$/;"	m	struct:eventop	access:public
recommended_backends	ev++.h	/^  inline unsigned int recommended_backends () throw ()$/;"	f	namespace:ev	signature:()
ref	ev++.h	/^    void ref () throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:()
reheap	ev.c	/^reheap (ANHE *heap, int N)$/;"	f	signature:(ANHE *heap, int N)
reify	ev.c	/^  unsigned char reify;  \/* flag set when this ANFD needs reification (EV_ANFD_REIFY, EV__IOFDSET) *\/$/;"	m	struct:__anon5	file:	access:public
release_cb	ev_wrap.h	180;"	d
release_cb	ev_wrap.h	81;"	d
remaining	ev++.h	/^    ev_tstamp remaining ()$/;"	f	namespace:ev	signature:()
repeat	ev.h	/^  ev_tstamp repeat; \/* rw *\/$/;"	m	struct:ev_timer	access:public
rfeedcnt	ev_wrap.h	181;"	d
rfeedcnt	ev_wrap.h	82;"	d
rfeedmax	ev_wrap.h	182;"	d
rfeedmax	ev_wrap.h	83;"	d
rfeeds	ev_wrap.h	183;"	d
rfeeds	ev_wrap.h	84;"	d
rpid	ev.h	/^  int rpid;    \/* rw, holds the received pid *\/$/;"	m	struct:ev_child	access:public
rstatus	ev.h	/^  int rstatus; \/* rw, holds the exit status, use the macros from sys\/wait.h *\/$/;"	m	struct:ev_child	access:public
rtmn_diff	ev_wrap.h	184;"	d
rtmn_diff	ev_wrap.h	85;"	d
run	ev++.h	/^    void run (int flags = 0)$/;"	f	struct:ev::loop_ref	access:public	signature:(int flags = 0)
sbindir	Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
select_destroy	ev_select.c	/^select_destroy (EV_P)$/;"	f
select_init	ev_select.c	/^select_init (EV_P_ int flags)$/;"	f	signature:(EV_P_ int flags)
select_modify	ev_select.c	/^select_modify (EV_P_ int fd, int oev, int nev)$/;"	f	file:	signature:(EV_P_ int fd, int oev, int nev)
select_poll	ev_select.c	/^select_poll (EV_P_ ev_tstamp timeout)$/;"	f	file:	signature:(EV_P_ ev_tstamp timeout)
send	ev++.h	/^    void send () throw ()$/;"	f	namespace:ev	signature:()
sent	ev.h	/^  EV_ATOMIC_T sent; \/* private *\/$/;"	m	struct:ev_async	access:public
set	ev++.h	/^      void set (EV_P) throw ()$/;"	f	struct:ev::base	access:public	signature:(EV_P)
set	ev++.h	/^    void set () throw () { }$/;"	f	namespace:ev	signature:()
set	ev++.h	/^    void set (K *object) throw ()$/;"	f	struct:ev::base	access:public	signature:(K *object)
set	ev++.h	/^    void set (const char *path, ev_tstamp interval = 0.) throw ()$/;"	f	namespace:ev	signature:(const char *path, ev_tstamp interval = 0.)
set	ev++.h	/^    void set (ev_tstamp after, ev_tstamp repeat = 0.) throw ()$/;"	f	namespace:ev	signature:(ev_tstamp after, ev_tstamp repeat = 0.)
set	ev++.h	/^    void set (ev_tstamp at, ev_tstamp interval = 0.) throw ()$/;"	f	namespace:ev	signature:(ev_tstamp at, ev_tstamp interval = 0.)
set	ev++.h	/^    void set (int events) throw ()$/;"	f	namespace:ev	signature:(int events)
set	ev++.h	/^    void set (int fd, int events) throw ()$/;"	f	namespace:ev	signature:(int fd, int events)
set	ev++.h	/^    void set (int pid, int trace = 0) throw ()$/;"	f	namespace:ev	signature:(int pid, int trace = 0)
set	ev++.h	/^    void set (int signum) throw ()$/;"	f	namespace:ev	signature:(int signum)
set	ev++.h	/^    void set (void *data = 0) throw ()$/;"	f	struct:ev::base	access:public	signature:(void *data = 0)
set_	ev++.h	/^    void set_ (const void *data, void (*cb)(EV_P_ ev_watcher *w, int revents)) throw ()$/;"	f	struct:ev::base	access:public	signature:(const void *data, void (*cb)(EV_P_ ev_watcher *w, int revents))
set_allocator	ev++.h	/^  inline void set_allocator (void *(*cb)(void *ptr, long size) throw ()) throw ()$/;"	f	namespace:ev	signature:(void *(*cb)(void *ptr, long size) throw ())
set_embed	ev++.h	/^    void set_embed (struct ev_loop *embedded_loop) throw ()$/;"	f	namespace:ev	signature:(struct ev_loop *embedded_loop)
set_io_collect_interval	ev++.h	/^    void set_io_collect_interval (tstamp interval) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(tstamp interval)
set_syserr_cb	ev++.h	/^  inline void set_syserr_cb (void (*cb)(const char *msg) throw ()) throw ()$/;"	f	namespace:ev	signature:(void (*cb)(const char *msg) throw ())
set_timeout_collect_interval	ev++.h	/^    void set_timeout_collect_interval (tstamp interval) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(tstamp interval)
sharedstatedir	Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sig	event.h	/^    struct ev_signal sig;$/;"	m	union:event::__anon4	typeref:struct:event::__anon4::ev_signal	access:public
sig_pending	ev_wrap.h	185;"	d
sig_pending	ev_wrap.h	86;"	d
sigfd	ev_wrap.h	186;"	d
sigfd	ev_wrap.h	87;"	d
sigfd_set	ev_wrap.h	187;"	d
sigfd_set	ev_wrap.h	88;"	d
sigfd_w	ev_wrap.h	188;"	d
sigfd_w	ev_wrap.h	89;"	d
sigfdcb	ev.c	/^sigfdcb (EV_P_ ev_io *iow, int revents)$/;"	f	file:	signature:(EV_P_ ev_io *iow, int revents)
signal	ev.h	/^  struct ev_signal signal;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_signal	access:public
signal_add	event.h	124;"	d
signal_del	event.h	126;"	d
signal_initialized	event.h	128;"	d
signal_pending	event.h	127;"	d
signal_set	event.h	125;"	d
signalfd	ev.c	/^EV_CPP (extern "C") int signalfd (int fd, const sigset_t *mask, int flags);$/;"	p	file:	signature:(int fd, const sigset_t *mask, int flags)
signalfd_siginfo	ev.c	/^struct signalfd_siginfo$/;"	s	file:
signalfd_siginfo::pad	ev.c	/^  char pad[128 - sizeof (uint32_t)];$/;"	m	struct:signalfd_siginfo	file:	access:public
signalfd_siginfo::ssi_signo	ev.c	/^  uint32_t ssi_signo;$/;"	m	struct:signalfd_siginfo	file:	access:public
signals	ev.c	/^static ANSIG signals [EV_NSIG - 1];$/;"	v	file:
signum	ev.h	/^  int signum; \/* ro *\/$/;"	m	struct:ev_signal	access:public
simpler_func_thunk	ev++.h	/^    static void simpler_func_thunk (int revents, void *arg)$/;"	f	struct:ev::loop_ref	access:public	signature:(int revents, void *arg)
simplest_func_thunk	ev++.h	/^    static void simplest_func_thunk (int revents, void *arg)$/;"	f	struct:ev::loop_ref	access:public	signature:(int revents, void *arg)
srcdir	Makefile	/^srcdir = .$/;"	m
ssi_signo	ev.c	/^  uint32_t ssi_signo;$/;"	m	struct:signalfd_siginfo	file:	access:public
start	ev++.h	/^    void start (const char *path, ev_tstamp interval = 0.) throw ()$/;"	f	namespace:ev	signature:(const char *path, ev_tstamp interval = 0.)
start	ev++.h	/^    void start (ev_tstamp after, ev_tstamp repeat = 0.) throw ()$/;"	f	namespace:ev	signature:(ev_tstamp after, ev_tstamp repeat = 0.)
start	ev++.h	/^    void start (ev_tstamp at, ev_tstamp interval = 0.) throw ()$/;"	f	namespace:ev	signature:(ev_tstamp at, ev_tstamp interval = 0.)
start	ev++.h	/^    void start (int fd, int events) throw ()$/;"	f	namespace:ev	signature:(int fd, int events)
start	ev++.h	/^    void start (int pid, int trace = 0) throw ()$/;"	f	namespace:ev	signature:(int pid, int trace = 0)
start	ev++.h	/^    void start (int signum) throw ()$/;"	f	namespace:ev	signature:(int signum)
start	ev++.h	/^    void start (struct ev_loop *embedded_loop) throw ()$/;"	f	namespace:ev	signature:(struct ev_loop *embedded_loop)
stat	ev.h	/^  struct ev_stat stat;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_stat	access:public
stat_timer_cb	ev.c	/^stat_timer_cb (EV_P_ ev_timer *w_, int revents)$/;"	f	file:	signature:(EV_P_ ev_timer *w_, int revents)
stat_timer_cb	ev.c	/^static void noinline stat_timer_cb (EV_P_ ev_timer *w_, int revents);$/;"	p	file:	signature:(EV_P_ ev_timer *w_, int revents)
subdir	Makefile	/^subdir = .$/;"	m
supported_backends	ev++.h	/^  inline unsigned int supported_backends () throw ()$/;"	f	namespace:ev	signature:()
sweep	ev++.h	/^    void sweep ()$/;"	f	namespace:ev	signature:()
sysconfdir	Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | xz -c >$(distdir).tar.xz$/;"	m
target_alias	Makefile	/^target_alias = $/;"	m
time_update	ev.c	/^time_update (EV_P_ ev_tstamp max_block)$/;"	f	signature:(EV_P_ ev_tstamp max_block)
timeout_add	event.h	118;"	d
timeout_blocktime	ev_wrap.h	189;"	d
timeout_blocktime	ev_wrap.h	90;"	d
timeout_del	event.h	120;"	d
timeout_initialized	event.h	122;"	d
timeout_pending	event.h	121;"	d
timeout_read	event_compat.h	/^	int timeout_read;	\/* in seconds *\/$/;"	m	struct:bufferevent	access:public
timeout_set	event.h	119;"	d
timeout_write	event_compat.h	/^	int timeout_write;	\/* in seconds *\/$/;"	m	struct:bufferevent	access:public
timer	ev.h	/^  ev_timer timer;        \/* unused *\/$/;"	m	struct:ev_embed	access:public
timer	ev.h	/^  ev_timer timer;     \/* private *\/$/;"	m	struct:ev_stat	access:public
timer	ev.h	/^  struct ev_timer timer;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_timer	access:public
timercnt	ev_wrap.h	190;"	d
timercnt	ev_wrap.h	91;"	d
timermax	ev_wrap.h	191;"	d
timermax	ev_wrap.h	92;"	d
timers	ev_wrap.h	192;"	d
timers	ev_wrap.h	93;"	d
timers_reify	ev.c	/^timers_reify (EV_P)$/;"	f
timers_reschedule	ev.c	/^timers_reschedule (EV_P_ ev_tstamp adjust)$/;"	f	file:	signature:(EV_P_ ev_tstamp adjust)
to	ev.c	/^  ev_timer to;$/;"	m	struct:ev_once	file:	access:public
to	event.h	/^  struct ev_timer to;$/;"	m	struct:event	typeref:struct:event::ev_timer	access:public
top_build_prefix	Makefile	/^top_build_prefix = $/;"	m
top_builddir	Makefile	/^top_builddir = .$/;"	m
top_distdir	Makefile	/^top_distdir = $(distdir)$/;"	m
top_srcdir	Makefile	/^top_srcdir = .$/;"	m
totallen	event_compat.h	/^	size_t totallen;$/;"	m	struct:evbuffer	access:public
transform	Makefile	/^transform = $(program_transform_name)$/;"	m
tstamp	ev++.h	/^  typedef ev_tstamp tstamp;$/;"	t	namespace:ev
u_char	event_compat.h	/^typedef unsigned char u_char;$/;"	t
u_short	event_compat.h	/^typedef unsigned short u_short;$/;"	t
uint16_t	ev.c	/^  typedef unsigned short uint16_t;$/;"	t	file:
uint32_t	ev.c	/^  typedef unsigned int   uint32_t;$/;"	t	file:
uint64_t	ev.c	/^    typedef unsigned __int64   uint64_t;$/;"	t	file:
uint64_t	ev.c	/^    typedef unsigned long long uint64_t;$/;"	t	file:
uint8_t	ev.c	/^  typedef unsigned char  uint8_t;$/;"	t	file:
uintptr_t	ev.c	/^    typedef uint32_t uintptr_t;$/;"	t	file:
uintptr_t	ev.c	/^    typedef uint64_t uintptr_t;$/;"	t	file:
unloop	ev++.h	/^    void unloop (how_t how = ONE) throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:(how_t how = ONE)
unref	ev++.h	/^    void unref () throw ()$/;"	f	struct:ev::loop_ref	access:public	signature:()
unused	ev.c	/^  unsigned char unused;$/;"	m	struct:__anon5	file:	access:public
update	ev++.h	/^    void update () throw ()$/;"	f	namespace:ev	signature:()
upheap	ev.c	/^upheap (ANHE *heap, int k)$/;"	f	signature:(ANHE *heap, int k)
userdata	ev_wrap.h	193;"	d
userdata	ev_wrap.h	94;"	d
value	event_compat.h	/^	char *value;$/;"	m	struct:evkeyval	access:public
vec_eo	ev_wrap.h	194;"	d
vec_eo	ev_wrap.h	95;"	d
vec_max	ev_wrap.h	195;"	d
vec_max	ev_wrap.h	96;"	d
vec_ri	ev_wrap.h	196;"	d
vec_ri	ev_wrap.h	97;"	d
vec_ro	ev_wrap.h	197;"	d
vec_ro	ev_wrap.h	98;"	d
vec_wi	ev_wrap.h	198;"	d
vec_wi	ev_wrap.h	99;"	d
vec_wo	ev_wrap.h	100;"	d
vec_wo	ev_wrap.h	199;"	d
verify_heap	ev.c	/^verify_heap (EV_P_ ANHE *heap, int N)$/;"	f	file:	signature:(EV_P_ ANHE *heap, int N)
verify_watcher	ev.c	/^verify_watcher (EV_P_ W w)$/;"	f	file:	signature:(EV_P_ W w)
version_major	ev++.h	/^  inline int version_major () throw ()$/;"	f	namespace:ev	signature:()
version_minor	ev++.h	/^  inline int version_minor () throw ()$/;"	f	namespace:ev	signature:()
w	ev.c	/^    WT w;$/;"	m	struct:__anon8	file:	access:public
w	ev.c	/^  W w;$/;"	m	struct:__anon6	file:	access:public
w	ev.h	/^  struct ev_watcher w;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_watcher	access:public
wd	ev.h	/^  int wd; \/* wd for inotify, fd for kqueue *\/$/;"	m	struct:ev_stat	access:public
wl	ev.h	/^  struct ev_watcher_list wl;$/;"	m	union:ev_any_watcher	typeref:struct:ev_any_watcher::ev_watcher_list	access:public
wlist_add	ev.c	/^wlist_add (WL *head, WL elem)$/;"	f	signature:(WL *head, WL elem)
wlist_del	ev.c	/^wlist_del (WL *head, WL elem)$/;"	f	signature:(WL *head, WL elem)
wm_read	event_compat.h	/^	struct event_watermark wm_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
wm_write	event_compat.h	/^	struct event_watermark wm_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
writecb	event_compat.h	/^	evbuffercb writecb;$/;"	m	struct:bufferevent	access:public
~dynamic_loop	ev++.h	/^    ~dynamic_loop () throw ()$/;"	f	struct:ev::dynamic_loop	access:public	signature:()
